# æ·±å…¥ç†è§£ FastAPI

> ç°ä»£Pythoné«˜æ€§èƒ½APIæ¡†æ¶çš„å®Œæ•´æŒ‡å—

## ç›®å½•

- [1. FastAPIæ¦‚è¿°ä¸æ ¸å¿ƒç‰¹æ€§](#1-fastapiæ¦‚è¿°ä¸æ ¸å¿ƒç‰¹æ€§)
- [2. å¼‚æ­¥ç¼–ç¨‹åŸç†](#2-å¼‚æ­¥ç¼–ç¨‹åŸç†)
- [3. Pydanticæ•°æ®éªŒè¯](#3-pydanticæ•°æ®éªŒè¯)
- [4. ä¾èµ–æ³¨å…¥ç³»ç»Ÿ](#4-ä¾èµ–æ³¨å…¥ç³»ç»Ÿ)
- [5. ä¸­é—´ä»¶ä¸ç”Ÿå‘½å‘¨æœŸ](#5-ä¸­é—´ä»¶ä¸ç”Ÿå‘½å‘¨æœŸ)
- [6. è®¤è¯ä¸å®‰å…¨](#6-è®¤è¯ä¸å®‰å…¨)
- [7. æ•°æ®åº“é›†æˆ](#7-æ•°æ®åº“é›†æˆ)
- [8. åå°ä»»åŠ¡ä¸WebSocket](#8-åå°ä»»åŠ¡ä¸websocket)
- [9. æµ‹è¯•ç­–ç•¥](#9-æµ‹è¯•ç­–ç•¥)
- [10. ç”Ÿäº§éƒ¨ç½²ä¸æ€§èƒ½ä¼˜åŒ–](#10-ç”Ÿäº§éƒ¨ç½²ä¸æ€§èƒ½ä¼˜åŒ–)

---

## 1. FastAPIæ¦‚è¿°ä¸æ ¸å¿ƒç‰¹æ€§

### 1.1 ä»€ä¹ˆæ˜¯FastAPI

FastAPIæ˜¯ä¸€ä¸ªç°ä»£ã€é«˜æ€§èƒ½çš„Python Webæ¡†æ¶ï¼Œä¸“é—¨ç”¨äºæ„å»ºAPIã€‚å®ƒè¯ç”Ÿäº2018å¹´ï¼Œç”±SebastiÃ¡n RamÃ­rezåˆ›å»ºï¼Œç›®æ ‡æ˜¯è§£å†³Python Webå¼€å‘ä¸­é•¿æœŸå­˜åœ¨çš„å‡ ä¸ªç—›ç‚¹ï¼š

**ä¼ ç»Ÿæ¡†æ¶çš„é—®é¢˜**ï¼š

- **Flask**ï¼šç®€å•çµæ´»ï¼Œä½†ç¼ºä¹æ•°æ®éªŒè¯ã€ç±»å‹æç¤ºæ”¯æŒï¼Œéœ€è¦å¤§é‡ç¬¬ä¸‰æ–¹åº“
- **Django REST Framework**ï¼šåŠŸèƒ½å¼ºå¤§ä½†è¿‡äºé‡é‡çº§ï¼Œå­¦ä¹ æ›²çº¿é™¡å³­
- **æ€§èƒ½ç“¶é¢ˆ**ï¼šä¼ ç»ŸåŒæ­¥æ¡†æ¶åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹è¡¨ç°ä¸ä½³

**FastAPIçš„è§£å†³æ–¹æ¡ˆ**ï¼š

FastAPIç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼Œå®ƒä¸æ˜¯ä»é›¶å¼€å§‹ï¼Œè€Œæ˜¯å·§å¦™åœ°ç»„åˆäº†ä¸¤ä¸ªä¼˜ç§€çš„åº“ï¼š

1. **Starlette**ï¼šæä¾›Webæ¡†æ¶çš„æ ¸å¿ƒèƒ½åŠ›ï¼ˆè·¯ç”±ã€ä¸­é—´ä»¶ã€WebSocketç­‰ï¼‰
2. **Pydantic**ï¼šæä¾›æ•°æ®éªŒè¯å’Œåºåˆ—åŒ–èƒ½åŠ›

è¿™ç§è®¾è®¡å“²å­¦æ„å‘³ç€FastAPIæœ¬èº«çš„ä»£ç é‡å¾ˆå°ï¼Œä½†åŠŸèƒ½æå…¶å¼ºå¤§ã€‚å½“ä½ ä½¿ç”¨FastAPIæ—¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨ä½¿ç”¨è¿™ä¸¤ä¸ªç»è¿‡ç”Ÿäº§éªŒè¯çš„æˆç†Ÿåº“ã€‚

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š

| ç‰¹æ€§ | è¯´æ˜ | å¯¹æ¯”ä¼ ç»Ÿæ¡†æ¶ |
|------|------|-------------|
| æé«˜æ€§èƒ½ | ä¸NodeJSã€Goç›¸å½“ | æ¯”Flaskå¿«10-100å€ |
| å¼€å‘æ•ˆç‡ | å¼€å‘é€Ÿåº¦æå‡200-300% | è‡ªåŠ¨æ–‡æ¡£ã€è‡ªåŠ¨éªŒè¯ |
| å‡å°‘Bug | ç±»å‹æç¤ºå‡å°‘çº¦40%çš„äººä¸ºé”™è¯¯ | ç¼–è¯‘æ—¶å‘ç°é—®é¢˜ |
| æ ‡å‡†åŒ– | åŸºäºOpenAPIå’ŒJSON Schema | æ— éœ€æ‰‹å†™APIæ–‡æ¡£ |
| å­¦ä¹ æ›²çº¿ | åªéœ€äº†è§£Pythonç±»å‹æ³¨è§£ | æ— éœ€å­¦ä¹ DSL |

### 1.2 å®‰è£…ä¸ç¯å¢ƒé…ç½®

FastAPIæä¾›äº†å¤šç§å®‰è£…æ–¹å¼ï¼Œæ ¹æ®ä½ çš„éœ€æ±‚é€‰æ‹©ï¼š

```bash
# æ–¹å¼1ï¼šæ ‡å‡†å®‰è£…ï¼ˆæ¨èï¼ŒåŒ…å«æ‰€æœ‰å¸¸ç”¨ä¾èµ–ï¼‰
# åŒ…å«ï¼šuvicornã€httpxã€jinja2ã€python-multipartç­‰
pip install "fastapi[standard]"

# æ–¹å¼2ï¼šæœ€å°å®‰è£…ï¼ˆåªæœ‰æ ¸å¿ƒåŠŸèƒ½ï¼‰
# é€‚åˆï¼šå¯¹ä¾èµ–æœ‰ä¸¥æ ¼æ§åˆ¶çš„ç¯å¢ƒ
pip install fastapi

# æ–¹å¼3ï¼šå•ç‹¬å®‰è£…ASGIæœåŠ¡å™¨
# å¦‚æœä½ é€‰æ‹©äº†æœ€å°å®‰è£…ï¼Œéœ€è¦å•ç‹¬å®‰è£…æœåŠ¡å™¨
pip install uvicorn[standard]
```

**ä¸ºä»€ä¹ˆéœ€è¦ASGIæœåŠ¡å™¨ï¼Ÿ**

FastAPIæœ¬èº«åªæ˜¯ä¸€ä¸ªæ¡†æ¶ï¼Œå®ƒå®šä¹‰äº†å¦‚ä½•å¤„ç†è¯·æ±‚ï¼Œä½†ä¸åŒ…å«ç½‘ç»œæœåŠ¡å™¨åŠŸèƒ½ã€‚ASGIï¼ˆAsynchronous Server Gateway Interfaceï¼‰æ˜¯Pythonå¼‚æ­¥Webåº”ç”¨çš„æ ‡å‡†æ¥å£ï¼ŒUvicornæ˜¯æœ€æµè¡Œçš„ASGIæœåŠ¡å™¨å®ç°ã€‚

è¿™ç§åˆ†ç¦»è®¾è®¡çš„å¥½å¤„æ˜¯ï¼š
- å¯ä»¥é€‰æ‹©ä¸åŒçš„ASGIæœåŠ¡å™¨ï¼ˆUvicornã€Hypercornã€Daphneï¼‰
- æ¡†æ¶ä¸“æ³¨äºä¸šåŠ¡é€»è¾‘ï¼ŒæœåŠ¡å™¨ä¸“æ³¨äºç½‘ç»œå¤„ç†
- æ–¹ä¾¿åœ¨ä¸åŒç¯å¢ƒï¼ˆå¼€å‘/ç”Ÿäº§ï¼‰ä½¿ç”¨ä¸åŒé…ç½®

**ç‰ˆæœ¬è¦æ±‚ä¸å…¼å®¹æ€§**ï¼š
- Python 3.8+ï¼ˆæ¨è3.10+ï¼Œå¯ä»¥ä½¿ç”¨ `|` è¯­æ³•æ›¿ä»£ `Union`ï¼‰
- FastAPI 0.100+ï¼ˆ2024-2025å¹´æ¨è0.115+ï¼‰

### 1.3 ç¬¬ä¸€ä¸ªFastAPIåº”ç”¨

è®©æˆ‘ä»¬ä»ä¸€ä¸ªå®Œæ•´ä½†ç®€å•çš„ä¾‹å­å¼€å§‹ï¼Œé€æ­¥ç†è§£FastAPIçš„æ ¸å¿ƒæ¦‚å¿µï¼š

```python
# main.py
from fastapi import FastAPI

# åˆ›å»ºFastAPIåº”ç”¨å®ä¾‹
# è¿™ä¸ªå®ä¾‹æ˜¯æ•´ä¸ªåº”ç”¨çš„å…¥å£ç‚¹ï¼Œæ‰€æœ‰è·¯ç”±ã€ä¸­é—´ä»¶éƒ½æ³¨å†Œåœ¨è¿™é‡Œ
app = FastAPI(
    title="My API",              # APIæ ‡é¢˜ï¼Œæ˜¾ç¤ºåœ¨æ–‡æ¡£ä¸­
    description="è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹API",  # APIæè¿°
    version="1.0.0",             # APIç‰ˆæœ¬
    docs_url="/docs",            # Swaggeræ–‡æ¡£è·¯å¾„ï¼ˆé»˜è®¤ï¼‰
    redoc_url="/redoc"           # ReDocæ–‡æ¡£è·¯å¾„ï¼ˆé»˜è®¤ï¼‰
)

# æœ€ç®€å•çš„è·¯ç”±ï¼šGETè¯·æ±‚ï¼Œè¿”å›JSON
@app.get("/")
async def root():
    """
    æ ¹è·¯å¾„ç«¯ç‚¹

    è¿™ä¸ªå‡½æ•°ä¼šåœ¨è®¿é—® / æ—¶è¢«è°ƒç”¨
    è¿”å›çš„å­—å…¸ä¼šè‡ªåŠ¨åºåˆ—åŒ–ä¸ºJSON
    """
    return {"message": "Hello World"}

# å¸¦è·¯å¾„å‚æ•°çš„è·¯ç”±
@app.get("/items/{item_id}")
async def read_item(item_id: int, q: str | None = None):
    """
    è·å–å•ä¸ªç‰©å“

    Args:
        item_id: è·¯å¾„å‚æ•°ï¼Œè‡ªåŠ¨è½¬æ¢ä¸ºintç±»å‹
        q: æŸ¥è¯¢å‚æ•°ï¼Œå¯é€‰ï¼Œé»˜è®¤ä¸ºNone

    FastAPIä¼šè‡ªåŠ¨ï¼š
    1. éªŒè¯item_idæ˜¯å¦ä¸ºæœ‰æ•ˆæ•´æ•°
    2. å¦‚æœéªŒè¯å¤±è´¥ï¼Œè¿”å›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
    3. å°†å‚æ•°ä¼ é€’ç»™å‡½æ•°
    """
    return {"item_id": item_id, "q": q}
```

**è¿è¡Œåº”ç”¨**ï¼š

```bash
# å¼€å‘æ¨¡å¼ï¼šå¯ç”¨è‡ªåŠ¨é‡è½½ï¼Œä»£ç ä¿®æ”¹åè‡ªåŠ¨é‡å¯
uvicorn main:app --reload

# è¿™ä¸ªå‘½ä»¤çš„å«ä¹‰ï¼š
# main - Pythonæ¨¡å—åï¼ˆmain.pyï¼‰
# app - FastAPIå®ä¾‹çš„å˜é‡å
# --reload - ç›‘è§†æ–‡ä»¶å˜åŒ–ï¼Œè‡ªåŠ¨é‡å¯
```

**ç†è§£è·¯ç”±è£…é¥°å™¨**ï¼š

```python
@app.get("/items/{item_id}")
```

è¿™ä¸€è¡Œä»£ç åšäº†å¾ˆå¤šäº‹æƒ…ï¼š
1. `@app.get` - æ³¨å†Œä¸€ä¸ªå¤„ç†GETè¯·æ±‚çš„è·¯ç”±
2. `"/items/{item_id}"` - URLè·¯å¾„æ¨¡æ¿ï¼Œ`{item_id}` æ˜¯è·¯å¾„å‚æ•°
3. è£…é¥°å™¨å°†å‡½æ•°ä¸è·¯å¾„ç»‘å®šï¼ŒFastAPIè‡ªåŠ¨å¤„ç†è¯·æ±‚åˆ†å‘

**è‡ªåŠ¨ç”Ÿæˆçš„æ–‡æ¡£**ï¼š

å¯åŠ¨åº”ç”¨åï¼Œè®¿é—®ä»¥ä¸‹åœ°å€ï¼š
- http://127.0.0.1:8000/docs - Swagger UIï¼ˆäº¤äº’å¼æ–‡æ¡£ï¼‰
- http://127.0.0.1:8000/redoc - ReDocï¼ˆç¾è§‚çš„é™æ€æ–‡æ¡£ï¼‰
- http://127.0.0.1:8000/openapi.json - OpenAPIè§„èŒƒJSON

è¿™äº›æ–‡æ¡£å®Œå…¨è‡ªåŠ¨ç”Ÿæˆï¼Œæ— éœ€ä»»ä½•é¢å¤–é…ç½®ã€‚FastAPIé€šè¿‡åˆ†æä½ çš„ä»£ç ï¼ˆç±»å‹æ³¨è§£ã€docstringï¼‰æ¥ç”Ÿæˆæ–‡æ¡£ã€‚

### 1.4 è¯·æ±‚å‚æ•°çš„å¤šç§æ¥æº

åœ¨Webå¼€å‘ä¸­ï¼Œå®¢æˆ·ç«¯æ•°æ®å¯ä»¥é€šè¿‡å¤šç§æ–¹å¼ä¼ é€’ã€‚FastAPIæä¾›äº†ç»Ÿä¸€ä¸”ç±»å‹å®‰å…¨çš„æ–¹å¼æ¥å¤„ç†æ‰€æœ‰è¿™äº›æ¥æºï¼š

```python
from fastapi import FastAPI, Query, Path, Body, Header, Cookie
from pydantic import BaseModel
from typing import Annotated

app = FastAPI()

# ==================== 1. è·¯å¾„å‚æ•° ====================
# è·¯å¾„å‚æ•°æ˜¯URLçš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºæ ‡è¯†ç‰¹å®šèµ„æº
# ä¾‹å¦‚ï¼š/users/123 ä¸­çš„ 123 å°±æ˜¯ç”¨æˆ·ID

@app.get("/users/{user_id}")
async def get_user(
    user_id: Annotated[int, Path(
        title="ç”¨æˆ·ID",
        description="è¦æŸ¥è¯¢çš„ç”¨æˆ·çš„å”¯ä¸€æ ‡è¯†ç¬¦",
        ge=1,           # å¤§äºç­‰äº1
        example=42      # æ–‡æ¡£ä¸­çš„ç¤ºä¾‹å€¼
    )]
):
    """
    Pathå‚æ•°çš„ç‰¹ç‚¹ï¼š
    - å¿…é¡»å­˜åœ¨ï¼ˆå¦åˆ™URLä¸åŒ¹é…ï¼‰
    - é€šå¸¸ç”¨äºèµ„æºæ ‡è¯†
    - æ”¯æŒç±»å‹éªŒè¯å’Œçº¦æŸ
    """
    return {"user_id": user_id}


# ==================== 2. æŸ¥è¯¢å‚æ•° ====================
# æŸ¥è¯¢å‚æ•°åœ¨URLçš„?åé¢ï¼Œç”¨äºè¿‡æ»¤ã€åˆ†é¡µã€æœç´¢ç­‰
# ä¾‹å¦‚ï¼š/items/?skip=0&limit=10&q=phone

@app.get("/items/")
async def list_items(
    # å¿…é€‰å‚æ•°ï¼šæ²¡æœ‰é»˜è®¤å€¼
    category: str,

    # å¯é€‰å‚æ•°ï¼šæœ‰é»˜è®¤å€¼
    skip: int = 0,

    # å¸¦éªŒè¯çš„å‚æ•°ï¼šä½¿ç”¨Queryæ·»åŠ çº¦æŸ
    limit: Annotated[int, Query(
        le=100,          # æœ€å¤§100
        description="è¿”å›ç»“æœæ•°é‡é™åˆ¶"
    )] = 10,

    # å¸¦é•¿åº¦éªŒè¯çš„å­—ç¬¦ä¸²å‚æ•°
    q: Annotated[str | None, Query(
        min_length=3,    # æœ€çŸ­3ä¸ªå­—ç¬¦
        max_length=50,   # æœ€é•¿50ä¸ªå­—ç¬¦
        pattern="^[a-zA-Z0-9]+$"  # åªå…è®¸å­—æ¯æ•°å­—
    )] = None
):
    """
    Queryå‚æ•°çš„ç‰¹ç‚¹ï¼š
    - ç”¨äºå¯é€‰çš„ç­›é€‰æ¡ä»¶
    - å¯ä»¥æœ‰é»˜è®¤å€¼
    - æ”¯æŒå¤æ‚çš„éªŒè¯è§„åˆ™
    - éå¿…é¡»ï¼ˆé™¤éæ²¡æœ‰é»˜è®¤å€¼ï¼‰
    """
    return {
        "category": category,
        "skip": skip,
        "limit": limit,
        "q": q
    }


# ==================== 3. è¯·æ±‚ä½“ ====================
# è¯·æ±‚ä½“ç”¨äºå‘é€å¤æ‚çš„ç»“æ„åŒ–æ•°æ®ï¼Œé€šå¸¸æ˜¯JSONæ ¼å¼
# å¸¸è§äºPOSTã€PUTã€PATCHè¯·æ±‚

class Item(BaseModel):
    """
    Pydanticæ¨¡å‹å®šä¹‰è¯·æ±‚ä½“ç»“æ„

    è¿™ä¸ä»…ä»…æ˜¯æ•°æ®å®¹å™¨ï¼Œå®ƒè¿˜æä¾›ï¼š
    - è‡ªåŠ¨JSONè§£æ
    - ç±»å‹éªŒè¯
    - è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ
    - IDEæ™ºèƒ½æç¤º
    """
    name: str
    price: float
    description: str | None = None
    tax: float | None = None

@app.post("/items/")
async def create_item(item: Item):
    """
    åˆ›å»ºæ–°ç‰©å“

    FastAPIçœ‹åˆ°å‚æ•°ç±»å‹æ˜¯Pydanticæ¨¡å‹ï¼Œ
    ä¼šè‡ªåŠ¨ä»è¯·æ±‚ä½“è¯»å–JSONå¹¶éªŒè¯
    """
    # item å·²ç»æ˜¯éªŒè¯è¿‡çš„ Item å®ä¾‹
    item_dict = item.model_dump()
    if item.tax:
        item_dict["price_with_tax"] = item.price + item.tax
    return item_dict


# ==================== 4. è¯·æ±‚å¤´ ====================
# HTTPå¤´éƒ¨é€šå¸¸ç”¨äºå…ƒæ•°æ®ï¼šè®¤è¯ã€å†…å®¹ç±»å‹ã€è¿½è¸ªIDç­‰

@app.get("/headers/")
async def read_headers(
    # Headerä¼šè‡ªåŠ¨å¤„ç†HTTPå¤´éƒ¨çš„å‘½åè½¬æ¢
    # X-Token åœ¨Pythonä¸­å˜æˆ x_token
    user_agent: Annotated[str | None, Header()] = None,
    x_request_id: Annotated[str | None, Header()] = None,
    authorization: Annotated[str | None, Header()] = None
):
    """
    Headerå‚æ•°çš„ç‰¹ç‚¹ï¼š
    - è‡ªåŠ¨è½¬æ¢ä¸‹åˆ’çº¿ä¸ºè¿å­—ç¬¦ï¼ˆx_token -> X-Tokenï¼‰
    - å¤§å°å†™ä¸æ•æ„Ÿ
    - å¸¸ç”¨äºè®¤è¯ã€è¿½è¸ªã€å†…å®¹åå•†
    """
    return {
        "User-Agent": user_agent,
        "X-Request-ID": x_request_id,
        "Authorization": authorization[:20] + "..." if authorization else None
    }


# ==================== 5. Cookie ====================
# Cookieç”¨äºå®¢æˆ·ç«¯çŠ¶æ€å­˜å‚¨ï¼Œå¦‚ä¼šè¯IDã€ç”¨æˆ·åå¥½ç­‰

@app.get("/cookies/")
async def read_cookies(
    session_id: Annotated[str | None, Cookie()] = None,
    preferences: Annotated[str | None, Cookie()] = None
):
    """
    Cookieå‚æ•°çš„ç‰¹ç‚¹ï¼š
    - ç”±æµè§ˆå™¨è‡ªåŠ¨å‘é€
    - å¸¸ç”¨äºä¼šè¯ç®¡ç†
    - æ³¨æ„å®‰å…¨æ€§ï¼ˆHttpOnlyã€Secureã€SameSiteï¼‰
    """
    return {
        "session_id": session_id,
        "preferences": preferences
    }
```

**Annotatedç±»å‹çš„è®¾è®¡å“²å­¦**ï¼š

ä½ å¯èƒ½æ³¨æ„åˆ°æˆ‘ä»¬ä½¿ç”¨äº† `Annotated[int, Query(...)]` è¿™ç§è¯­æ³•ã€‚è¿™æ˜¯Python 3.9å¼•å…¥çš„ç±»å‹æ³¨è§£å¢å¼ºï¼ŒFastAPIå……åˆ†åˆ©ç”¨äº†è¿™ä¸€ç‰¹æ€§ï¼š

```python
# ä¼ ç»Ÿæ–¹å¼ï¼ˆä»ç„¶æ”¯æŒï¼Œä½†ä¸æ¨èï¼‰
def old_style(q: str = Query(default=None, min_length=3)):
    pass

# ç°ä»£æ–¹å¼ï¼ˆæ¨èï¼‰
def new_style(q: Annotated[str | None, Query(min_length=3)] = None):
    pass
```

ä½¿ç”¨Annotatedçš„å¥½å¤„ï¼š
1. **ç±»å‹å’Œå…ƒæ•°æ®åˆ†ç¦»**ï¼šç±»å‹æ£€æŸ¥å·¥å…·åªçœ‹åˆ° `str | None`
2. **æ›´æ¸…æ™°çš„é»˜è®¤å€¼**ï¼šé»˜è®¤å€¼åœ¨æœ€åï¼Œä¸€ç›®äº†ç„¶
3. **å¯å¤ç”¨**ï¼šå¯ä»¥åˆ›å»ºç±»å‹åˆ«åå¤ç”¨éªŒè¯è§„åˆ™

```python
# åˆ›å»ºå¯å¤ç”¨çš„ç±»å‹åˆ«å
PositiveInt = Annotated[int, Query(gt=0)]
SearchQuery = Annotated[str | None, Query(min_length=3, max_length=50)]

# åœ¨å¤šä¸ªè·¯ç”±ä¸­å¤ç”¨
@app.get("/products/")
async def list_products(page: PositiveInt = 1, q: SearchQuery = None):
    pass

@app.get("/orders/")
async def list_orders(page: PositiveInt = 1, q: SearchQuery = None):
    pass
```

---

## 2. å¼‚æ­¥ç¼–ç¨‹åŸç†

### 2.1 ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ï¼Ÿ

è¦ç†è§£å¼‚æ­¥ç¼–ç¨‹çš„ä»·å€¼ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç†è§£WebæœåŠ¡å™¨é¢ä¸´çš„æŒ‘æˆ˜ï¼š

**ä¼ ç»ŸåŒæ­¥æ¨¡å‹çš„é—®é¢˜**ï¼š

æƒ³è±¡ä¸€ä¸ªé¤å…åªæœ‰ä¸€ä¸ªæœåŠ¡å‘˜ã€‚åŒæ­¥æ¨¡å‹ä¸‹ï¼Œè¿™ä¸ªæœåŠ¡å‘˜ï¼š
1. æ¥å¾…å®¢äººAï¼Œè®°å½•ç‚¹å•
2. å»å¨æˆ¿ç­‰å¾…Açš„èœåšå¥½
3. æŠŠèœç«¯ç»™A
4. ç„¶åæ‰èƒ½æœåŠ¡å®¢äººB

å¦‚æœåšä¸€é“èœéœ€è¦10åˆ†é’Ÿï¼Œè¿™ä¸ªæœåŠ¡å‘˜ä¸€å°æ—¶åªèƒ½æœåŠ¡6ä½å®¢äººã€‚

**å¼‚æ­¥æ¨¡å‹çš„è§£å†³æ–¹æ¡ˆ**ï¼š

èªæ˜çš„æœåŠ¡å‘˜ä¼šè¿™æ ·åšï¼š
1. æ¥å¾…å®¢äººAï¼Œè®°å½•ç‚¹å•ï¼Œæäº¤ç»™å¨æˆ¿
2. ä¸ç­‰å¾…ï¼Œç«‹å³å»æ¥å¾…å®¢äººB
3. è®°å½•Bçš„ç‚¹å•ï¼Œæäº¤å¨æˆ¿
4. ç»§ç»­æ¥å¾…Cã€Dã€E...
5. å½“å¨æˆ¿é€šçŸ¥æŸé“èœå¥½äº†ï¼Œå†å»ç«¯èœ

è¿™å°±æ˜¯å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒæ€æƒ³ï¼š**ä¸è¦å‚»ç­‰ï¼Œå»åšåˆ«çš„äº‹**ã€‚

```python
import asyncio
import httpx
from fastapi import FastAPI
import time

app = FastAPI()

# ==================== åŒæ­¥æ–¹å¼ï¼ˆé˜»å¡ï¼‰ ====================
@app.get("/sync")
def sync_endpoint():
    """
    åŒæ­¥è¯·æ±‚ç¤ºä¾‹

    é—®é¢˜ï¼š
    - è¿™ä¸ªå‡½æ•°æ‰§è¡ŒæœŸé—´ï¼Œæ•´ä¸ªworkeréƒ½åœ¨ç­‰å¾…
    - å¦‚æœå¤–éƒ¨APIå“åº”éœ€è¦2ç§’ï¼Œè¿™ä¸ªworker 2ç§’å†…æ— æ³•å¤„ç†å…¶ä»–è¯·æ±‚
    - åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œè¿™ä¼šå¯¼è‡´ä¸¥é‡çš„æ€§èƒ½é—®é¢˜
    """
    import requests
    # å‘èµ·HTTPè¯·æ±‚ï¼Œçº¿ç¨‹é˜»å¡ç­‰å¾…å“åº”
    response = requests.get("https://api.example.com/data")
    return response.json()


# ==================== å¼‚æ­¥æ–¹å¼ï¼ˆéé˜»å¡ï¼‰ ====================
@app.get("/async")
async def async_endpoint():
    """
    å¼‚æ­¥è¯·æ±‚ç¤ºä¾‹

    ä¼˜åŠ¿ï¼š
    - awaitæœŸé—´ï¼Œäº‹ä»¶å¾ªç¯å¯ä»¥å¤„ç†å…¶ä»–è¯·æ±‚
    - å•ä¸ªworkerå¯ä»¥åŒæ—¶å¤„ç†æ•°ç™¾ä¸ªå¹¶å‘è¯·æ±‚
    - èµ„æºåˆ©ç”¨ç‡å¤§å¹…æå‡
    """
    async with httpx.AsyncClient() as client:
        # awaitè¡¨ç¤ºï¼šå‘èµ·è¯·æ±‚åï¼Œè®©å‡ºæ§åˆ¶æƒï¼Œç­‰å“åº”å›æ¥å†ç»§ç»­
        response = await client.get("https://api.example.com/data")
        return response.json()
```

### 2.2 æ·±å…¥ç†è§£ async/await

`async` å’Œ `await` æ˜¯Pythonå¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒå…³é”®å­—ï¼Œç†è§£å®ƒä»¬çš„æœ¬è´¨å¾ˆé‡è¦ï¼š

**async def - å®šä¹‰åç¨‹å‡½æ•°**ï¼š

```python
async def my_coroutine():
    """
    async def å®šä¹‰äº†ä¸€ä¸ªåç¨‹å‡½æ•°

    è°ƒç”¨è¿™ä¸ªå‡½æ•°ä¸ä¼šç«‹å³æ‰§è¡Œå‡½æ•°ä½“ï¼Œ
    è€Œæ˜¯è¿”å›ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œéœ€è¦è¢«awaitæˆ–äº‹ä»¶å¾ªç¯è°ƒåº¦
    """
    return "Hello"

# ç›´æ¥è°ƒç”¨ä¸ä¼šæ‰§è¡Œå‡½æ•°ä½“
coro = my_coroutine()  # è¿”å›åç¨‹å¯¹è±¡ <coroutine object my_coroutine at 0x...>

# å¿…é¡»awaitæ‰ä¼šçœŸæ­£æ‰§è¡Œ
result = await my_coroutine()  # è¿”å› "Hello"
```

**await - ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ**ï¼š

```python
async def fetch_data(url: str) -> dict:
    """æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®è·å–"""
    await asyncio.sleep(1)  # æ¨¡æ‹ŸI/Oæ“ä½œï¼Œè¿™1ç§’å†…å¯ä»¥å¤„ç†å…¶ä»–è¯·æ±‚
    return {"url": url, "data": "some data"}

async def process_data(data: dict) -> dict:
    """æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®å¤„ç†"""
    await asyncio.sleep(0.5)  # æ¨¡æ‹ŸI/Oæ“ä½œ
    return {"processed": True, **data}
```

**ä¸²è¡Œ vs å¹¶è¡Œæ‰§è¡Œ**ï¼š

ç†è§£è¿™ä¸¤ç§æ¨¡å¼çš„åŒºåˆ«å¯¹å†™å‡ºé«˜æ•ˆçš„å¼‚æ­¥ä»£ç è‡³å…³é‡è¦ï¼š

```python
# ==================== ä¸²è¡Œæ‰§è¡Œ ====================
@app.get("/serial")
async def serial_execution():
    """
    ä¸²è¡Œæ‰§è¡Œï¼šæ€»è€—æ—¶ = 1ç§’ + 1ç§’ = 2ç§’

    é€‚ç”¨åœºæ™¯ï¼š
    - ç¬¬äºŒä¸ªæ“ä½œä¾èµ–ç¬¬ä¸€ä¸ªçš„ç»“æœ
    - éœ€è¦ä¿è¯æ‰§è¡Œé¡ºåº
    """
    start = time.time()

    # å…ˆæ‰§è¡Œç¬¬ä¸€ä¸ªï¼Œç­‰å¾…å®Œæˆ
    data1 = await fetch_data("url1")  # ç­‰å¾…1ç§’
    # å†æ‰§è¡Œç¬¬äºŒä¸ª
    data2 = await fetch_data("url2")  # å†ç­‰å¾…1ç§’

    print(f"ä¸²è¡Œè€—æ—¶: {time.time() - start:.2f}ç§’")  # çº¦2ç§’
    return [data1, data2]


# ==================== å¹¶è¡Œæ‰§è¡Œ ====================
@app.get("/parallel")
async def parallel_execution():
    """
    å¹¶è¡Œæ‰§è¡Œï¼šæ€»è€—æ—¶ = max(1ç§’, 1ç§’) = 1ç§’

    é€‚ç”¨åœºæ™¯ï¼š
    - å¤šä¸ªç‹¬ç«‹çš„I/Oæ“ä½œ
    - æ“ä½œä¹‹é—´æ²¡æœ‰ä¾èµ–å…³ç³»
    """
    start = time.time()

    # asyncio.gather åŒæ—¶å¯åŠ¨å¤šä¸ªåç¨‹
    # å®ƒä»¬ä¼šå¹¶å‘æ‰§è¡Œï¼Œç­‰å¾…æœ€æ…¢çš„é‚£ä¸ªå®Œæˆ
    data1, data2 = await asyncio.gather(
        fetch_data("url1"),  # å¯åŠ¨
        fetch_data("url2")   # åŒæ—¶å¯åŠ¨
    )

    print(f"å¹¶è¡Œè€—æ—¶: {time.time() - start:.2f}ç§’")  # çº¦1ç§’
    return [data1, data2]


# ==================== TaskGroupï¼ˆPython 3.11+ï¼‰ ====================
@app.get("/taskgroup")
async def taskgroup_execution():
    """
    TaskGroupæ˜¯Python 3.11å¼•å…¥çš„æ›´ç°ä»£çš„å¹¶å‘æ§åˆ¶æ–¹å¼

    ç›¸æ¯”asyncio.gatherçš„ä¼˜åŠ¿ï¼š
    - æ›´å¥½çš„å¼‚å¸¸å¤„ç†ï¼šä¸€ä¸ªä»»åŠ¡å¤±è´¥ä¼šå–æ¶ˆæ‰€æœ‰å…¶ä»–ä»»åŠ¡
    - ç»“æ„åŒ–å¹¶å‘ï¼šä»»åŠ¡æœ‰æ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸè¾¹ç•Œ
    - ä»£ç æ›´æ¸…æ™°
    """
    start = time.time()

    async with asyncio.TaskGroup() as tg:
        # åˆ›å»ºä»»åŠ¡ï¼Œç«‹å³å¼€å§‹æ‰§è¡Œ
        task1 = tg.create_task(fetch_data("url1"))
        task2 = tg.create_task(fetch_data("url2"))

    # é€€å‡ºä¸Šä¸‹æ–‡ç®¡ç†å™¨æ—¶ï¼Œæ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
    print(f"TaskGroupè€—æ—¶: {time.time() - start:.2f}ç§’")
    return [task1.result(), task2.result()]
```

### 2.3 ä½•æ—¶ä½¿ç”¨ async def vs def

è¿™æ˜¯FastAPIæ–°æ‰‹æœ€å¸¸è§çš„å›°æƒ‘ä¹‹ä¸€ã€‚ç®€å•çš„åˆ¤æ–­æ ‡å‡†ï¼š

**ä½¿ç”¨ async def**ï¼š
- å‡½æ•°å†…éƒ¨æœ‰ `await` è°ƒç”¨
- è¿›è¡Œå¼‚æ­¥I/Oæ“ä½œï¼ˆasyncæ•°æ®åº“ã€async HTTPå®¢æˆ·ç«¯ï¼‰

**ä½¿ç”¨æ™®é€š def**ï¼š
- çº¯CPUè®¡ç®—
- ä½¿ç”¨åŒæ­¥åº“ï¼ˆå¦‚ `requests`ã€åŒæ­¥æ•°æ®åº“é©±åŠ¨ï¼‰

```python
from fastapi import FastAPI
import time

app = FastAPI()

# ==================== åœºæ™¯1ï¼šå¼‚æ­¥I/Oæ“ä½œ ====================
@app.get("/io-bound")
async def io_bound():
    """
    ä½¿ç”¨ async defï¼šé€‚åˆI/Oå¯†é›†å‹æ“ä½œ

    I/Oæ“ä½œçš„ç‰¹ç‚¹æ˜¯å¤§éƒ¨åˆ†æ—¶é—´åœ¨ç­‰å¾…ï¼š
    - ç­‰å¾…æ•°æ®åº“å“åº”
    - ç­‰å¾…HTTPè¯·æ±‚å“åº”
    - ç­‰å¾…æ–‡ä»¶è¯»å†™å®Œæˆ
    """
    async with httpx.AsyncClient() as client:
        # è¿™ä¸ªawaitæœŸé—´ï¼Œäº‹ä»¶å¾ªç¯å¯ä»¥å¤„ç†å…¶ä»–è¯·æ±‚
        response = await client.get("https://api.example.com/data")
        return response.json()


# ==================== åœºæ™¯2ï¼šCPUå¯†é›†å‹æ“ä½œ ====================
@app.get("/cpu-bound")
def cpu_bound():
    """
    ä½¿ç”¨æ™®é€š defï¼šé€‚åˆCPUå¯†é›†å‹æ“ä½œ

    FastAPIçš„æ™ºèƒ½å¤„ç†ï¼š
    - æ™®é€šå‡½æ•°ä¼šåœ¨çº¿ç¨‹æ± ä¸­è¿è¡Œ
    - ä¸ä¼šé˜»å¡äº‹ä»¶å¾ªç¯
    - ä½†è¦æ³¨æ„ï¼šçº¿ç¨‹æ± å¤§å°æœ‰é™ï¼ˆé»˜è®¤40ä¸ªçº¿ç¨‹ï¼‰
    """
    # æ¨¡æ‹ŸCPUå¯†é›†è®¡ç®—
    result = sum(i * i for i in range(1000000))
    return {"result": result}


# ==================== åé¢æ•™æï¼šé˜»å¡äº‹ä»¶å¾ªç¯ ====================
@app.get("/bad-example")
async def bad_example():
    """
    âŒ é”™è¯¯ç¤ºèŒƒï¼šåœ¨asyncå‡½æ•°ä¸­ä½¿ç”¨é˜»å¡æ“ä½œ

    é—®é¢˜ï¼š
    - time.sleepæ˜¯åŒæ­¥é˜»å¡è°ƒç”¨
    - åœ¨asyncå‡½æ•°ä¸­ï¼Œå®ƒä¼šé˜»å¡æ•´ä¸ªäº‹ä»¶å¾ªç¯
    - æ‰€æœ‰å…¶ä»–è¯·æ±‚éƒ½è¦ç­‰è¿™5ç§’è¿‡å»
    """
    time.sleep(5)  # åƒä¸‡åˆ«è¿™æ ·åšï¼
    return {"status": "done"}


# ==================== æ­£ç¡®å¤„ç†ï¼šä½¿ç”¨run_in_executor ====================
@app.get("/good-example")
async def good_example():
    """
    âœ“ æ­£ç¡®ç¤ºèŒƒï¼šå°†é˜»å¡æ“ä½œæ”¾åˆ°çº¿ç¨‹æ± 

    å¦‚æœå¿…é¡»ä½¿ç”¨åŒæ­¥é˜»å¡å‡½æ•°ï¼ˆæ¯”å¦‚æŸäº›é—ç•™åº“ï¼‰ï¼Œ
    ä½¿ç”¨run_in_executorå°†å…¶æ”¾åˆ°çº¿ç¨‹æ± æ‰§è¡Œ
    """
    loop = asyncio.get_event_loop()
    # åœ¨çº¿ç¨‹æ± ä¸­è¿è¡Œé˜»å¡æ“ä½œï¼Œä¸ä¼šé˜»å¡äº‹ä»¶å¾ªç¯
    await loop.run_in_executor(None, time.sleep, 5)
    return {"status": "done"}
```

### 2.4 å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ä¸åº”ç”¨ç”Ÿå‘½å‘¨æœŸ

ç°ä»£FastAPIåº”ç”¨é€šå¸¸éœ€è¦ç®¡ç†å„ç§èµ„æºï¼šæ•°æ®åº“è¿æ¥æ± ã€HTTPå®¢æˆ·ç«¯ã€ç¼“å­˜è¿æ¥ç­‰ã€‚è¿™äº›èµ„æºåº”è¯¥åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆ›å»ºï¼Œå…³é—­æ—¶æ¸…ç†ã€‚

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
import httpx
from sqlalchemy.ext.asyncio import create_async_engine

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨

    è¿™æ˜¯FastAPIæ¨èçš„èµ„æºç®¡ç†æ–¹å¼ï¼ˆæ›¿ä»£äº†æ—§çš„on_eventè£…é¥°å™¨ï¼‰

    è®¾è®¡æ¨¡å¼ï¼š
    - yieldä¹‹å‰çš„ä»£ç åœ¨åº”ç”¨å¯åŠ¨æ—¶æ‰§è¡Œï¼ˆåˆå§‹åŒ–ï¼‰
    - yieldä¹‹åçš„ä»£ç åœ¨åº”ç”¨å…³é—­æ—¶æ‰§è¡Œï¼ˆæ¸…ç†ï¼‰
    - é€šè¿‡app.stateå­˜å‚¨å…±äº«èµ„æº
    """

    # ===== å¯åŠ¨æ—¶æ‰§è¡Œ =====
    print("ğŸš€ åº”ç”¨å¯åŠ¨ä¸­...")

    # 1. åˆå§‹åŒ–æ•°æ®åº“è¿æ¥æ± 
    # ä¸ºä»€ä¹ˆè¦åœ¨å¯åŠ¨æ—¶åˆ›å»ºï¼Ÿ
    # - è¿æ¥æ± åˆ›å»ºéœ€è¦æ—¶é—´ï¼Œä¸åº”è¯¥è®©ç¬¬ä¸€ä¸ªè¯·æ±‚ç­‰å¾…
    # - è¿æ¥æ± åº”è¯¥è¢«æ‰€æœ‰è¯·æ±‚å…±äº«ï¼Œè€Œä¸æ˜¯æ¯ä¸ªè¯·æ±‚åˆ›å»º
    app.state.db_engine = create_async_engine(
        "postgresql+asyncpg://user:pass@localhost/db",
        pool_size=10,      # æ± ä¸­ä¿æŒçš„è¿æ¥æ•°
        max_overflow=20,   # è¶…å‡ºpool_sizeæ—¶å¯ä»¥é¢å¤–åˆ›å»ºçš„è¿æ¥æ•°
        pool_recycle=3600  # è¿æ¥1å°æ—¶åå›æ”¶ï¼Œé¿å…æ•°æ®åº“è¶…æ—¶æ–­å¼€
    )

    # 2. åˆå§‹åŒ–HTTPå®¢æˆ·ç«¯
    # ä¸ºä»€ä¹ˆè¦å¤ç”¨å®¢æˆ·ç«¯ï¼Ÿ
    # - HTTPè¿æ¥å»ºç«‹éœ€è¦TCPæ¡æ‰‹ã€å¯èƒ½çš„TLSæ¡æ‰‹ï¼Œå¼€é”€å¤§
    # - å¤ç”¨å®¢æˆ·ç«¯å¯ä»¥ä½¿ç”¨HTTPè¿æ¥æ± ï¼Œå¤§å¹…å‡å°‘å»¶è¿Ÿ
    app.state.http_client = httpx.AsyncClient(
        timeout=30.0,
        limits=httpx.Limits(
            max_keepalive_connections=20,
            max_connections=100
        )
    )

    # 3. åˆå§‹åŒ–Redisè¿æ¥
    import redis.asyncio as aioredis
    app.state.redis = await aioredis.from_url(
        "redis://localhost",
        encoding="utf-8",
        decode_responses=True
    )

    print("âœ… æ‰€æœ‰æœåŠ¡åˆå§‹åŒ–å®Œæˆ!")

    yield  # åº”ç”¨è¿è¡Œä¸­ï¼Œå¤„ç†è¯·æ±‚

    # ===== å…³é—­æ—¶æ‰§è¡Œ =====
    print("ğŸ›‘ åº”ç”¨å…³é—­ä¸­...")

    # ä¼˜é›…å…³é—­æ‰€æœ‰è¿æ¥
    # ä¸ºä»€ä¹ˆéœ€è¦ä¼˜é›…å…³é—­ï¼Ÿ
    # - ç¡®ä¿æ­£åœ¨è¿›è¡Œçš„æ•°æ®åº“äº‹åŠ¡èƒ½å¤Ÿå®Œæˆ
    # - é‡Šæ”¾ç³»ç»Ÿèµ„æºï¼ˆæ–‡ä»¶æè¿°ç¬¦ã€å†…å­˜ï¼‰
    # - é¿å…è¿æ¥æ³„æ¼å¯¼è‡´æ•°æ®åº“è¿æ¥æ± è€—å°½

    await app.state.db_engine.dispose()
    await app.state.http_client.aclose()
    await app.state.redis.close()

    print("ğŸ‘‹ åº”ç”¨å·²å®‰å…¨å…³é—­")

# åˆ›å»ºåº”ç”¨ï¼Œä¼ å…¥ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
app = FastAPI(lifespan=lifespan)

@app.get("/external-api")
async def call_external():
    """
    ä½¿ç”¨å…±äº«çš„HTTPå®¢æˆ·ç«¯

    å¥½å¤„ï¼š
    - å¤ç”¨è¿æ¥æ± ï¼Œå‡å°‘è¿æ¥å»ºç«‹å¼€é”€
    - ç»Ÿä¸€çš„è¶…æ—¶é…ç½®
    - åº”ç”¨å…³é—­æ—¶è‡ªåŠ¨æ¸…ç†
    """
    client = app.state.http_client
    response = await client.get("https://api.github.com/zen")
    return {"github_zen": response.text}

@app.get("/cache/{key}")
async def get_cache(key: str):
    """ä½¿ç”¨å…±äº«çš„Redisè¿æ¥"""
    value = await app.state.redis.get(key)
    return {"key": key, "value": value}
```

---

## 3. Pydanticæ•°æ®éªŒè¯

### 3.1 ä¸ºä»€ä¹ˆéœ€è¦æ•°æ®éªŒè¯ï¼Ÿ

åœ¨Webå¼€å‘ä¸­ï¼Œæ°¸è¿œä¸è¦ä¿¡ä»»å®¢æˆ·ç«¯æ•°æ®ã€‚ç”¨æˆ·å¯èƒ½ï¼š
- è¾“å…¥é”™è¯¯çš„æ•°æ®ç±»å‹ï¼ˆå­—ç¬¦ä¸²ä»£æ›¿æ•°å­—ï¼‰
- è¾“å…¥ä¸ç¬¦åˆä¸šåŠ¡è§„åˆ™çš„æ•°æ®ï¼ˆè´Ÿæ•°ä»·æ ¼ã€ç©ºç”¨æˆ·åï¼‰
- æ¶æ„è¾“å…¥ï¼ˆSQLæ³¨å…¥ã€XSSæ”»å‡»ï¼‰

ä¼ ç»Ÿæ–¹å¼éœ€è¦å¤§é‡æ‰‹åŠ¨éªŒè¯ä»£ç ï¼š

```python
# ä¼ ç»Ÿæ–¹å¼ï¼šç¹çä¸”å®¹æ˜“é—æ¼
def create_user_old(data: dict):
    if "username" not in data:
        raise ValueError("ç¼ºå°‘ç”¨æˆ·å")
    if not isinstance(data["username"], str):
        raise ValueError("ç”¨æˆ·åå¿…é¡»æ˜¯å­—ç¬¦ä¸²")
    if len(data["username"]) < 3:
        raise ValueError("ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦")
    if len(data["username"]) > 50:
        raise ValueError("ç”¨æˆ·åæœ€å¤š50ä¸ªå­—ç¬¦")
    # ... è¿˜æœ‰emailã€passwordç­‰å­—æ®µ
    # ä»£ç å†—é•¿ï¼Œå®¹æ˜“å‡ºé”™ï¼Œç»´æŠ¤å›°éš¾
```

Pydanticé€šè¿‡å£°æ˜å¼çš„æ–¹å¼è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

```python
from pydantic import BaseModel, Field, field_validator, model_validator
from datetime import datetime
from enum import Enum
from typing import Self

# ä½¿ç”¨æšä¸¾é™åˆ¶æœ‰æ•ˆå€¼
class UserRole(str, Enum):
    """
    ç”¨æˆ·è§’è‰²æšä¸¾

    ç»§æ‰¿strçš„å¥½å¤„ï¼š
    - JSONåºåˆ—åŒ–æ—¶è‡ªåŠ¨è½¬ä¸ºå­—ç¬¦ä¸²
    - å¯ä»¥ç›´æ¥ä¸å­—ç¬¦ä¸²æ¯”è¾ƒ
    """
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"


class UserBase(BaseModel):
    """
    ç”¨æˆ·åŸºç¡€æ¨¡å‹

    BaseModelçš„é­”åŠ›ï¼š
    - è‡ªåŠ¨ä»JSON/dictè§£ææ•°æ®
    - è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼ˆ"123" -> 123ï¼‰
    - è‡ªåŠ¨éªŒè¯çº¦æŸ
    - ç”ŸæˆJSON Schemaï¼ˆç”¨äºAPIæ–‡æ¡£ï¼‰
    """

    # Fieldæä¾›æ›´è¯¦ç»†çš„éªŒè¯è§„åˆ™
    username: str = Field(
        ...,              # ... è¡¨ç¤ºå¿…å¡«å­—æ®µ
        min_length=3,     # æœ€çŸ­3ä¸ªå­—ç¬¦
        max_length=50,    # æœ€é•¿50ä¸ªå­—ç¬¦
        examples=["john_doe"]  # æ–‡æ¡£ç¤ºä¾‹
    )

    # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼éªŒè¯emailæ ¼å¼
    email: str = Field(
        ...,
        pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$',
        examples=["user@example.com"]
    )

    # æšä¸¾ç±»å‹ï¼Œåªæ¥å—å®šä¹‰çš„å€¼
    role: UserRole = UserRole.USER


class UserCreate(UserBase):
    """
    åˆ›å»ºç”¨æˆ·æ—¶çš„è¯·æ±‚æ¨¡å‹

    ç»§æ‰¿UserBaseï¼Œé¢å¤–æ·»åŠ passwordå­—æ®µ
    è¿™ç§åˆ†å±‚è®¾è®¡å¾ˆå¸¸è§ï¼š
    - UserBase: å…±äº«çš„åŸºç¡€å­—æ®µ
    - UserCreate: åˆ›å»ºæ—¶çš„è¾“å…¥ï¼ˆåŒ…å«å¯†ç ï¼‰
    - UserResponse: è¿”å›ç»™å®¢æˆ·ç«¯çš„æ•°æ®ï¼ˆä¸åŒ…å«å¯†ç ï¼‰
    """

    password: str = Field(..., min_length=8)

    @field_validator('password')
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """
        è‡ªå®šä¹‰å­—æ®µéªŒè¯å™¨

        éªŒè¯å¯†ç å¼ºåº¦ï¼š
        - å¿…é¡»åŒ…å«å¤§å†™å­—æ¯
        - å¿…é¡»åŒ…å«æ•°å­—
        """
        if not any(c.isupper() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªå¤§å†™å­—æ¯')
        if not any(c.isdigit() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªæ•°å­—')
        return v


class UserResponse(UserBase):
    """
    è¿”å›ç»™å®¢æˆ·ç«¯çš„ç”¨æˆ·æ¨¡å‹

    æ³¨æ„ï¼šä¸åŒ…å«passwordå­—æ®µ
    è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æœ€ä½³å®è·µï¼šæ°¸è¿œä¸è¦å°†å¯†ç è¿”å›ç»™å®¢æˆ·ç«¯
    """
    id: int
    created_at: datetime

    model_config = {
        "from_attributes": True  # å…è®¸ä»ORMæ¨¡å‹åˆ›å»º
    }
```

### 3.2 é«˜çº§éªŒè¯æŠ€å·§

Pydantic v2æä¾›äº†å¼ºå¤§çš„éªŒè¯èƒ½åŠ›ï¼Œè®©æˆ‘ä»¬çœ‹å‡ ä¸ªå®é™…åœºæ™¯ï¼š

```python
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Self
from decimal import Decimal

class Order(BaseModel):
    """
    è®¢å•æ¨¡å‹ - å±•ç¤ºå¤šç§éªŒè¯æŠ€å·§
    """
    product_id: int
    quantity: int = Field(gt=0, description="è´­ä¹°æ•°é‡ï¼Œå¿…é¡»å¤§äº0")
    unit_price: Decimal = Field(gt=0, decimal_places=2)
    discount: float = Field(ge=0, le=1, default=0, description="æŠ˜æ‰£ç‡ï¼Œ0-1ä¹‹é—´")
    total: Decimal | None = None  # è®¡ç®—å­—æ®µï¼Œå…è®¸ä¸ºç©º

    @field_validator('quantity')
    @classmethod
    def validate_quantity(cls, v: int) -> int:
        """
        å•å­—æ®µéªŒè¯å™¨

        ä½¿ç”¨åœºæ™¯ï¼š
        - æ£€æŸ¥åº“å­˜ï¼ˆéœ€è¦æŸ¥è¯¢æ•°æ®åº“ï¼‰
        - ä¸šåŠ¡è§„åˆ™é™åˆ¶
        """
        if v > 1000:
            raise ValueError('å•æ¬¡è®¢å•æ•°é‡ä¸èƒ½è¶…è¿‡1000')
        return v

    @model_validator(mode='after')
    def calculate_total(self) -> Self:
        """
        æ¨¡å‹éªŒè¯å™¨ - åœ¨æ‰€æœ‰å­—æ®µéªŒè¯å®Œæˆåæ‰§è¡Œ

        mode='after' è¡¨ç¤ºåœ¨å­—æ®µéªŒè¯åæ‰§è¡Œ
        mode='before' è¡¨ç¤ºåœ¨å­—æ®µéªŒè¯å‰æ‰§è¡Œï¼ˆç”¨äºé¢„å¤„ç†åŸå§‹æ•°æ®ï¼‰

        è¿™é‡Œç”¨äºè®¡ç®—æ´¾ç”Ÿå­—æ®µ
        """
        if self.total is None:
            self.total = self.quantity * self.unit_price * Decimal(1 - self.discount)
        return self


class DateRange(BaseModel):
    """
    æ—¥æœŸèŒƒå›´ - å±•ç¤ºè·¨å­—æ®µéªŒè¯
    """
    start_date: datetime
    end_date: datetime

    @model_validator(mode='after')
    def validate_date_range(self) -> Self:
        """
        éªŒè¯ç»“æŸæ—¥æœŸå¿…é¡»æ™šäºå¼€å§‹æ—¥æœŸ

        è¿™ç§è·¨å­—æ®µéªŒè¯åªèƒ½ç”¨model_validatorå®ç°
        """
        if self.end_date <= self.start_date:
            raise ValueError('ç»“æŸæ—¥æœŸå¿…é¡»æ™šäºå¼€å§‹æ—¥æœŸ')
        return self


class BatchRequest(BaseModel):
    """
    æ‰¹é‡è¯·æ±‚ - å±•ç¤ºåˆ—è¡¨éªŒè¯
    """
    orders: list[Order]

    @model_validator(mode='after')
    def validate_batch(self) -> Self:
        """éªŒè¯æ‰¹é‡æ“ä½œçš„çº¦æŸ"""
        if len(self.orders) > 100:
            raise ValueError('æ‰¹é‡è®¢å•ä¸èƒ½è¶…è¿‡100ä¸ª')

        # æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„product_id
        product_ids = [o.product_id for o in self.orders]
        if len(product_ids) != len(set(product_ids)):
            raise ValueError('æ‰¹é‡è®¢å•ä¸­å­˜åœ¨é‡å¤çš„äº§å“')

        return self
```

### 3.3 æ³›å‹å“åº”æ¨¡å‹

åœ¨å®é™…é¡¹ç›®ä¸­ï¼ŒAPIå“åº”é€šå¸¸æœ‰ç»Ÿä¸€çš„æ ¼å¼ã€‚ä½¿ç”¨æ³›å‹å¯ä»¥åˆ›å»ºå¯å¤ç”¨çš„å“åº”åŒ…è£…å™¨ï¼š

```python
from pydantic import BaseModel, Field
from typing import Generic, TypeVar
from datetime import datetime

# å®šä¹‰ç±»å‹å˜é‡
T = TypeVar('T')

class Response(BaseModel, Generic[T]):
    """
    é€šç”¨å“åº”åŒ…è£…å™¨

    ä¸ºä»€ä¹ˆéœ€è¦ç»Ÿä¸€çš„å“åº”æ ¼å¼ï¼Ÿ
    - å‰ç«¯å¯ä»¥ç”¨ç»Ÿä¸€çš„é€»è¾‘å¤„ç†æ‰€æœ‰å“åº”
    - ä¾¿äºé”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
    - APIæ–‡æ¡£æ›´åŠ ä¸€è‡´
    """
    code: int = Field(default=200, description="ä¸šåŠ¡çŠ¶æ€ç ")
    message: str = Field(default="success", description="çŠ¶æ€æ¶ˆæ¯")
    data: T | None = Field(default=None, description="å“åº”æ•°æ®")
    timestamp: datetime = Field(default_factory=datetime.now)

    @classmethod
    def success(cls, data: T, message: str = "success") -> "Response[T]":
        """ä¾¿æ·æ–¹æ³•ï¼šåˆ›å»ºæˆåŠŸå“åº”"""
        return cls(code=200, message=message, data=data)

    @classmethod
    def error(cls, code: int, message: str) -> "Response[None]":
        """ä¾¿æ·æ–¹æ³•ï¼šåˆ›å»ºé”™è¯¯å“åº”"""
        return cls(code=code, message=message, data=None)


class PaginatedResponse(BaseModel, Generic[T]):
    """
    åˆ†é¡µå“åº”åŒ…è£…å™¨

    åˆ†é¡µæ˜¯APIè®¾è®¡ä¸­æœ€å¸¸è§çš„éœ€æ±‚ä¹‹ä¸€
    """
    items: list[T]
    total: int = Field(description="æ€»è®°å½•æ•°")
    page: int = Field(description="å½“å‰é¡µç ")
    page_size: int = Field(description="æ¯é¡µå¤§å°")
    pages: int = Field(description="æ€»é¡µæ•°")
    has_next: bool = Field(description="æ˜¯å¦æœ‰ä¸‹ä¸€é¡µ")
    has_prev: bool = Field(description="æ˜¯å¦æœ‰ä¸Šä¸€é¡µ")

    @classmethod
    def create(
        cls,
        items: list[T],
        total: int,
        page: int,
        page_size: int
    ) -> "PaginatedResponse[T]":
        """
        å·¥å‚æ–¹æ³•ï¼šæ ¹æ®å‚æ•°è®¡ç®—åˆ†é¡µä¿¡æ¯

        ä¸ºä»€ä¹ˆç”¨å·¥å‚æ–¹æ³•ï¼Ÿ
        - å°è£…è®¡ç®—é€»è¾‘
        - ç¡®ä¿å­—æ®µä¸€è‡´æ€§
        - å‡å°‘è°ƒç”¨æ–¹çš„é‡å¤ä»£ç 
        """
        pages = (total + page_size - 1) // page_size  # å‘ä¸Šå–æ•´
        return cls(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            pages=pages,
            has_next=page < pages,
            has_prev=page > 1
        )


# å…·ä½“çš„ä¸šåŠ¡æ¨¡å‹
class User(BaseModel):
    id: int
    username: str
    email: str

class Article(BaseModel):
    id: int
    title: str
    content: str


# åœ¨è·¯ç”±ä¸­ä½¿ç”¨æ³›å‹å“åº”
@app.get("/users", response_model=Response[PaginatedResponse[User]])
async def list_users(page: int = 1, page_size: int = 10):
    """
    è·å–ç”¨æˆ·åˆ—è¡¨

    response_modelçš„ä½œç”¨ï¼š
    - è‡ªåŠ¨åºåˆ—åŒ–å“åº”
    - è¿‡æ»¤å¤šä½™å­—æ®µï¼ˆå¦‚å¯†ç ï¼‰
    - ç”ŸæˆOpenAPIæ–‡æ¡£
    """
    # æ¨¡æ‹Ÿæ•°æ®
    total = 100
    users = [User(id=i, username=f"user_{i}", email=f"user{i}@example.com")
             for i in range((page-1)*page_size, min(page*page_size, total))]

    paginated = PaginatedResponse.create(
        items=users,
        total=total,
        page=page,
        page_size=page_size
    )

    return Response.success(paginated)
```

### 3.4 é…ç½®ç®¡ç†

Pydantic Settingsæ˜¯ç®¡ç†åº”ç”¨é…ç½®çš„æœ€ä½³å®è·µï¼š

```python
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, SecretStr
from functools import lru_cache

class Settings(BaseSettings):
    """
    åº”ç”¨é…ç½®ç±»

    è®¾è®¡åŸåˆ™ï¼ˆ12-Factor Appï¼‰ï¼š
    - é…ç½®ä¸ä»£ç åˆ†ç¦»
    - ä»ç¯å¢ƒå˜é‡è¯»å–æ•æ„Ÿä¿¡æ¯
    - æœ‰åˆç†çš„é»˜è®¤å€¼
    """

    # ===== åº”ç”¨åŸºç¡€é…ç½® =====
    app_name: str = "My FastAPI App"
    debug: bool = False
    environment: str = Field(default="development", pattern="^(development|staging|production)$")

    # ===== æ•°æ®åº“é…ç½® =====
    database_url: str = Field(
        ...,  # å¿…å¡«
        description="æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²",
        examples=["postgresql://user:pass@localhost/db"]
    )
    database_pool_size: int = Field(default=5, ge=1, le=50)
    database_max_overflow: int = Field(default=10, ge=0)

    # ===== Redisé…ç½® =====
    redis_url: str = "redis://localhost:6379/0"
    redis_max_connections: int = 10

    # ===== JWTé…ç½® =====
    # ä½¿ç”¨SecretStrå­˜å‚¨æ•æ„Ÿä¿¡æ¯
    # å®ƒä¸ä¼šåœ¨æ—¥å¿—ã€reprä¸­æ˜¾ç¤ºå®é™…å€¼
    secret_key: SecretStr
    algorithm: str = "HS256"
    access_token_expire_minutes: int = Field(default=30, ge=1)
    refresh_token_expire_days: int = Field(default=7, ge=1)

    # ===== å¤–éƒ¨æœåŠ¡é…ç½® =====
    openai_api_key: SecretStr | None = None
    sentry_dsn: str | None = None

    # ===== é…ç½®æ¥æºè®¾ç½® =====
    model_config = SettingsConfigDict(
        env_file=".env",           # ä».envæ–‡ä»¶è¯»å–
        env_file_encoding="utf-8",
        case_sensitive=False,      # ç¯å¢ƒå˜é‡åä¸åŒºåˆ†å¤§å°å†™
        extra="ignore"             # å¿½ç•¥.envä¸­å¤šä½™çš„å˜é‡
    )


@lru_cache
def get_settings() -> Settings:
    """
    è·å–é…ç½®å•ä¾‹

    ä¸ºä»€ä¹ˆç”¨lru_cacheï¼Ÿ
    - é…ç½®åªéœ€è¦åŠ è½½ä¸€æ¬¡
    - é¿å…é‡å¤è¯»å–ç¯å¢ƒå˜é‡å’Œ.envæ–‡ä»¶
    - ä¿è¯æ•´ä¸ªåº”ç”¨ä½¿ç”¨åŒä¸€ä¸ªé…ç½®å®ä¾‹
    """
    return Settings()


# åœ¨FastAPIä¸­ä½¿ç”¨é…ç½®
from fastapi import Depends

@app.get("/config")
async def get_config(settings: Settings = Depends(get_settings)):
    """
    æ˜¾ç¤ºï¼ˆå®‰å…¨çš„ï¼‰é…ç½®ä¿¡æ¯

    æ³¨æ„ï¼š
    - ä¸è¦æš´éœ²æ•æ„Ÿä¿¡æ¯
    - ç”Ÿäº§ç¯å¢ƒåº”è¯¥ç¦ç”¨è¿™ä¸ªç«¯ç‚¹
    """
    if settings.environment == "production":
        return {"error": "Not available in production"}

    return {
        "app_name": settings.app_name,
        "environment": settings.environment,
        "debug": settings.debug,
        # SecretStrçš„get_secret_value()æ–¹æ³•è·å–å®é™…å€¼
        # ä½†è¿™é‡Œæˆ‘ä»¬åªæ˜¾ç¤ºæ˜¯å¦å·²é…ç½®
        "openai_configured": settings.openai_api_key is not None
    }
```

---

## 4. ä¾èµ–æ³¨å…¥ç³»ç»Ÿ

### 4.1 ä»€ä¹ˆæ˜¯ä¾èµ–æ³¨å…¥ï¼Ÿ

ä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼ŒDIï¼‰æ˜¯è½¯ä»¶è®¾è®¡ä¸­çš„ä¸€ä¸ªé‡è¦æ¨¡å¼ã€‚æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**ä¸è¦åœ¨å‡½æ•°å†…éƒ¨åˆ›å»ºä¾èµ–ï¼Œè€Œæ˜¯ä»å¤–éƒ¨æ³¨å…¥**ã€‚

**æ²¡æœ‰ä¾èµ–æ³¨å…¥çš„ä»£ç **ï¼š

```python
# ç´§è€¦åˆçš„ä»£ç 
def get_user_orders(user_id: int):
    # å‡½æ•°å†…éƒ¨ç›´æ¥åˆ›å»ºæ•°æ®åº“è¿æ¥
    # é—®é¢˜ï¼š
    # 1. éš¾ä»¥æµ‹è¯•ï¼ˆæ— æ³•æ¨¡æ‹Ÿæ•°æ®åº“ï¼‰
    # 2. éš¾ä»¥å¤ç”¨ï¼ˆè¿æ¥é…ç½®å†™æ­»ï¼‰
    # 3. èµ„æºç®¡ç†å›°éš¾ï¼ˆè¿æ¥ä½•æ—¶å…³é—­ï¼Ÿï¼‰
    db = DatabaseConnection("postgresql://...")
    orders = db.query(f"SELECT * FROM orders WHERE user_id = {user_id}")
    db.close()
    return orders
```

**ä½¿ç”¨ä¾èµ–æ³¨å…¥çš„ä»£ç **ï¼š

```python
# æ¾è€¦åˆçš„ä»£ç 
def get_user_orders(user_id: int, db: DatabaseConnection):
    # æ•°æ®åº“è¿æ¥ä»å¤–éƒ¨ä¼ å…¥
    # ä¼˜åŠ¿ï¼š
    # 1. å¯æµ‹è¯•ï¼ˆä¼ å…¥Mockæ•°æ®åº“ï¼‰
    # 2. å¯å¤ç”¨ï¼ˆä¸å…³å¿ƒè¿æ¥æ¥æºï¼‰
    # 3. å…³æ³¨ç‚¹åˆ†ç¦»
    orders = db.query(f"SELECT * FROM orders WHERE user_id = {user_id}")
    return orders
```

FastAPIçš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿè®©è¿™ä¸€åˆ‡å˜å¾—ç®€å•ä¼˜é›…ï¼š

```python
from fastapi import FastAPI, Depends, HTTPException, status
from typing import Annotated

app = FastAPI()

# ===== å®šä¹‰ä¾èµ– =====
async def common_parameters(
    q: str | None = None,
    skip: int = 0,
    limit: int = 100
):
    """
    å…¬å…±æŸ¥è¯¢å‚æ•°ä¾èµ–

    è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ä¾èµ–å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªå­—å…¸
    FastAPIä¼šï¼š
    1. åˆ†æå‡½æ•°ç­¾åï¼Œè·å–å‚æ•°
    2. ä»è¯·æ±‚ä¸­æå–å‚æ•°å€¼
    3. è°ƒç”¨å‡½æ•°è·å–ä¾èµ–å€¼
    4. å°†ç»“æœæ³¨å…¥åˆ°è·¯ç”±å‡½æ•°
    """
    return {"q": q, "skip": skip, "limit": limit}


# åˆ›å»ºç±»å‹åˆ«åï¼Œæé«˜å¯è¯»æ€§
CommonParams = Annotated[dict, Depends(common_parameters)]


@app.get("/items/")
async def read_items(commons: CommonParams):
    """
    è¿™é‡Œçš„commonsä¼šè‡ªåŠ¨è·å¾—common_parametersçš„è¿”å›å€¼

    æ‰§è¡Œæµç¨‹ï¼š
    1. è¯·æ±‚åˆ°è¾¾ /items/?q=test&skip=10
    2. FastAPIè°ƒç”¨common_parameters(q="test", skip=10, limit=100)
    3. è¿”å›å€¼ {"q": "test", "skip": 10, "limit": 100}
    4. è¿™ä¸ªå­—å…¸ä½œä¸ºcommonså‚æ•°ä¼ ç»™read_items
    """
    return {"items": [...], "params": commons}


@app.get("/users/")
async def read_users(commons: CommonParams):
    """
    åŒæ ·çš„ä¾èµ–å¯ä»¥åœ¨å¤šä¸ªè·¯ç”±ä¸­å¤ç”¨
    è¿™å°±æ˜¯ä¾èµ–æ³¨å…¥çš„å¨åŠ›ï¼šä»£ç å¤ç”¨ + å…³æ³¨ç‚¹åˆ†ç¦»
    """
    return {"users": [...], "params": commons}
```

### 4.2 ç±»ä½œä¸ºä¾èµ–

å½“ä¾èµ–é€»è¾‘å¤æ‚æ—¶ï¼Œä½¿ç”¨ç±»å¯ä»¥æä¾›æ›´å¥½çš„ç»„ç»‡å’Œå°è£…ï¼š

```python
from fastapi import Depends, Query
from typing import Annotated

class Pagination:
    """
    åˆ†é¡µå‚æ•°ä¾èµ–ç±»

    ä½¿ç”¨ç±»çš„ä¼˜åŠ¿ï¼š
    - å¯ä»¥æœ‰å®ä¾‹å±æ€§ï¼Œå­˜å‚¨è®¡ç®—åçš„å€¼
    - å¯ä»¥æœ‰æ–¹æ³•ï¼Œæä¾›é¢å¤–åŠŸèƒ½
    - æ›´å¥½çš„IDEæ”¯æŒå’Œç±»å‹æç¤º
    """

    def __init__(
        self,
        page: int = Query(1, ge=1, description="é¡µç ï¼Œä»1å¼€å§‹"),
        page_size: int = Query(10, ge=1, le=100, description="æ¯é¡µæ•°é‡")
    ):
        """
        åˆå§‹åŒ–æ–¹æ³•å°±åƒæ™®é€šä¾èµ–å‡½æ•°ä¸€æ ·å·¥ä½œ

        FastAPIä¼šï¼š
        1. åˆ†æ__init__çš„å‚æ•°
        2. ä»è¯·æ±‚ä¸­æå–pageå’Œpage_size
        3. åˆ›å»ºPaginationå®ä¾‹
        """
        self.page = page
        self.page_size = page_size
        # è®¡ç®—æ´¾ç”Ÿå€¼
        self.skip = (page - 1) * page_size
        self.limit = page_size

    def paginate(self, query):
        """ä¾¿æ·æ–¹æ³•ï¼šåº”ç”¨åˆ†é¡µåˆ°SQLAlchemyæŸ¥è¯¢"""
        return query.offset(self.skip).limit(self.limit)


@app.get("/items/")
async def list_items(
    # Depends()ä¸å¸¦å‚æ•°æ—¶ï¼ŒFastAPIä¼šå®ä¾‹åŒ–Paginationç±»
    pagination: Annotated[Pagination, Depends()]
):
    """
    paginationæ˜¯Paginationç±»çš„å®ä¾‹
    å¯ä»¥è®¿é—®å…¶å±æ€§å’Œæ–¹æ³•
    """
    return {
        "page": pagination.page,
        "page_size": pagination.page_size,
        "skip": pagination.skip,
        "limit": pagination.limit
    }
```

### 4.3 ä¾èµ–é“¾ï¼šæ„å»ºå¤æ‚çš„ä¾èµ–å…³ç³»

FastAPIçš„ä¾èµ–å¯ä»¥ç»„æˆé“¾å¼ç»“æ„ï¼Œè§£å†³å¤æ‚çš„ä¾èµ–å…³ç³»ï¼š

```python
from fastapi import Depends, HTTPException, status
from typing import Annotated

# ===== ç¬¬ä¸€å±‚ï¼šåŸºç¡€è®¾æ–½ä¾èµ– =====
async def get_db():
    """
    æ•°æ®åº“ä¼šè¯ä¾èµ–

    ä½¿ç”¨yieldçš„ä¾èµ–ï¼ˆä¸Šä¸‹æ–‡ä¾èµ–ï¼‰ï¼š
    - yieldä¹‹å‰çš„ä»£ç åœ¨è¯·æ±‚å¤„ç†å‰æ‰§è¡Œ
    - yieldçš„å€¼ä½œä¸ºä¾èµ–æ³¨å…¥
    - yieldä¹‹åçš„ä»£ç åœ¨è¯·æ±‚å¤„ç†åæ‰§è¡Œï¼ˆæ— è®ºæˆåŠŸè¿˜æ˜¯å¼‚å¸¸ï¼‰
    """
    db = SessionLocal()
    try:
        yield db
        await db.commit()  # æˆåŠŸåˆ™æäº¤
    except Exception:
        await db.rollback()  # å¼‚å¸¸åˆ™å›æ»š
        raise
    finally:
        await db.close()  # æ— è®ºå¦‚ä½•éƒ½å…³é—­è¿æ¥


# ===== ç¬¬äºŒå±‚ï¼šè®¤è¯ä¾èµ– =====
async def get_current_user(
    token: str = Depends(oauth2_scheme),  # ä»è¯·æ±‚å¤´è·å–token
    db: Session = Depends(get_db)          # éœ€è¦æ•°æ®åº“æ¥éªŒè¯ç”¨æˆ·
) -> User:
    """
    è·å–å½“å‰ç™»å½•ç”¨æˆ·

    è¿™æ˜¯ä¸€ä¸ªç»„åˆä¾èµ–ï¼š
    - ä¾èµ–oauth2_schemeè·å–token
    - ä¾èµ–get_dbè·å–æ•°æ®åº“ä¼šè¯

    æ‰§è¡Œé¡ºåºï¼š
    1. oauth2_schemeä»è¯·æ±‚å¤´æå–token
    2. get_dbåˆ›å»ºæ•°æ®åº“ä¼šè¯
    3. æœ¬å‡½æ•°éªŒè¯tokenï¼ŒæŸ¥è¯¢ç”¨æˆ·
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="æ— æ³•éªŒè¯å‡­æ®",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # éªŒè¯token
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    # æŸ¥è¯¢ç”¨æˆ·
    user = await db.get(User, user_id)
    if user is None:
        raise credentials_exception

    return user


# ===== ç¬¬ä¸‰å±‚ï¼šæƒé™æ£€æŸ¥ä¾èµ– =====
async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
) -> User:
    """
    è·å–æ´»è·ƒç”¨æˆ·

    åœ¨get_current_userçš„åŸºç¡€ä¸Šï¼Œé¢å¤–æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«ç¦ç”¨
    """
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="ç”¨æˆ·å·²è¢«ç¦ç”¨"
        )
    return current_user


# ===== ç¬¬å››å±‚ï¼šè§’è‰²æ£€æŸ¥ä¾èµ– =====
def require_role(required_role: str):
    """
    è§’è‰²æ£€æŸ¥ä¾èµ–å·¥å‚

    è¿™æ˜¯ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªä¾èµ–
    å…è®¸å‚æ•°åŒ–ä¾èµ–è¡Œä¸º
    """
    async def role_checker(
        current_user: Annotated[User, Depends(get_current_active_user)]
    ) -> User:
        if current_user.role != required_role:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"éœ€è¦ {required_role} è§’è‰²"
            )
        return current_user

    return role_checker


# ===== åœ¨è·¯ç”±ä¸­ä½¿ç”¨ =====

@app.get("/users/me")
async def read_current_user(
    user: Annotated[User, Depends(get_current_active_user)]
):
    """ä»»ä½•ç™»å½•ç”¨æˆ·éƒ½å¯ä»¥è®¿é—®"""
    return user

@app.get("/admin/users")
async def admin_list_users(
    admin: Annotated[User, Depends(require_role("admin"))],
    db: Annotated[Session, Depends(get_db)]
):
    """
    åªæœ‰ç®¡ç†å‘˜å¯ä»¥è®¿é—®

    ä¾èµ–æ‰§è¡Œé¡ºåºï¼š
    1. oauth2_schemeæå–token
    2. get_dbåˆ›å»ºæ•°æ®åº“ä¼šè¯
    3. get_current_useréªŒè¯tokenï¼Œè·å–ç”¨æˆ·
    4. get_current_active_useræ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    5. require_role("admin")æ£€æŸ¥è§’è‰²
    6. æœ€åæ‰§è¡Œè·¯ç”±å‡½æ•°
    """
    users = await db.query(User).all()
    return users
```

### 4.4 è·¯ç”±çº§åˆ«ä¾èµ–

æœ‰æ—¶å€™ä½ éœ€è¦ç»™ä¸€ç»„è·¯ç”±æ·»åŠ ç›¸åŒçš„ä¾èµ–ï¼ŒFastAPIæ”¯æŒåœ¨è·¯ç”±å™¨çº§åˆ«å£°æ˜ä¾èµ–ï¼š

```python
from fastapi import APIRouter, Depends

# åˆ›å»ºä¸€ä¸ªéœ€è¦è®¤è¯çš„è·¯ç”±å™¨
authenticated_router = APIRouter(
    prefix="/protected",
    tags=["Protected"],
    # è¿™é‡Œçš„ä¾èµ–ä¼šåº”ç”¨åˆ°è¿™ä¸ªè·¯ç”±å™¨ä¸‹çš„æ‰€æœ‰è·¯ç”±
    dependencies=[Depends(get_current_active_user)]
)

@authenticated_router.get("/resource1")
async def get_resource1():
    """è‡ªåŠ¨éœ€è¦è®¤è¯"""
    return {"resource": "1"}

@authenticated_router.get("/resource2")
async def get_resource2():
    """è‡ªåŠ¨éœ€è¦è®¤è¯"""
    return {"resource": "2"}


# åˆ›å»ºä¸€ä¸ªç®¡ç†å‘˜è·¯ç”±å™¨
admin_router = APIRouter(
    prefix="/admin",
    tags=["Admin"],
    dependencies=[Depends(require_role("admin"))]
)

@admin_router.get("/dashboard")
async def admin_dashboard():
    """åªæœ‰ç®¡ç†å‘˜å¯ä»¥è®¿é—®"""
    return {"status": "admin area"}


# å°†è·¯ç”±å™¨æ³¨å†Œåˆ°ä¸»åº”ç”¨
app.include_router(authenticated_router)
app.include_router(admin_router)
```

---

## 5. ä¸­é—´ä»¶ä¸ç”Ÿå‘½å‘¨æœŸ

### 5.1 ç†è§£ä¸­é—´ä»¶

ä¸­é—´ä»¶æ˜¯å¤„ç†è¯·æ±‚/å“åº”çš„"å±‚"ï¼Œå®ƒåœ¨è·¯ç”±å‡½æ•°æ‰§è¡Œå‰åè¿è¡Œï¼Œé€‚åˆå®ç°æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼ˆCross-Cutting Concernsï¼‰ã€‚

**ä¸­é—´ä»¶çš„æ‰§è¡Œæµç¨‹**ï¼š

```
è¯·æ±‚ â†’ ä¸­é—´ä»¶A(å‰) â†’ ä¸­é—´ä»¶B(å‰) â†’ è·¯ç”±å‡½æ•° â†’ ä¸­é—´ä»¶B(å) â†’ ä¸­é—´ä»¶A(å) â†’ å“åº”
```

åƒæ´‹è‘±ä¸€æ ·ï¼Œåæ·»åŠ çš„ä¸­é—´ä»¶åœ¨å†…å±‚ã€‚

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
import time
import uuid
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

# ===== è‡ªå®šä¹‰ä¸­é—´ä»¶ =====
@app.middleware("http")
async def request_middleware(request: Request, call_next):
    """
    è¯·æ±‚å¤„ç†ä¸­é—´ä»¶

    è¿™ä¸ªä¸­é—´ä»¶åšä¸‰ä»¶äº‹ï¼š
    1. ç”Ÿæˆè¯·æ±‚IDï¼ˆç”¨äºè¿½è¸ªï¼‰
    2. è®°å½•è¯·æ±‚å¼€å§‹
    3. è®¡ç®—å¤„ç†æ—¶é—´
    """
    # ç”Ÿæˆå”¯ä¸€è¯·æ±‚ID
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))

    # è®°å½•è¯·æ±‚å¼€å§‹æ—¶é—´
    start_time = time.time()

    # å°†request_idå­˜å…¥request.stateï¼Œä¾›è·¯ç”±å‡½æ•°ä½¿ç”¨
    request.state.request_id = request_id

    logger.info(f"[{request_id}] å¼€å§‹å¤„ç†: {request.method} {request.url.path}")

    try:
        # è°ƒç”¨ä¸‹ä¸€ä¸ªä¸­é—´ä»¶æˆ–è·¯ç”±
        # è¿™æ˜¯å…³é”®ï¼ä¸è°ƒç”¨call_nextè¯·æ±‚å°±ä¸ä¼šè¢«å¤„ç†
        response = await call_next(request)

        # è®¡ç®—å¤„ç†æ—¶é—´
        process_time = time.time() - start_time

        # åœ¨å“åº”å¤´ä¸­æ·»åŠ æœ‰ç”¨ä¿¡æ¯
        response.headers["X-Request-ID"] = request_id
        response.headers["X-Process-Time"] = f"{process_time:.4f}"

        logger.info(
            f"[{request_id}] å¤„ç†å®Œæˆ: {response.status_code} "
            f"è€—æ—¶ {process_time:.4f}s"
        )

        return response

    except Exception as e:
        # è®°å½•å¼‚å¸¸
        process_time = time.time() - start_time
        logger.error(
            f"[{request_id}] å¤„ç†å¼‚å¸¸: {str(e)} "
            f"è€—æ—¶ {process_time:.4f}s"
        )
        raise


# ===== CORSä¸­é—´ä»¶ =====
# CORSï¼ˆè·¨æºèµ„æºå…±äº«ï¼‰æ˜¯Webå®‰å…¨çš„é‡è¦æœºåˆ¶
app.add_middleware(
    CORSMiddleware,
    # å…è®¸çš„æº
    # å¼€å‘ç¯å¢ƒå¯ä»¥ç”¨["*"]ï¼Œç”Ÿäº§ç¯å¢ƒåº”è¯¥æ˜ç¡®æŒ‡å®š
    allow_origins=[
        "http://localhost:3000",     # æœ¬åœ°å‰ç«¯
        "https://myapp.com",         # ç”Ÿäº§å‰ç«¯
    ],
    # æ˜¯å¦å…è®¸æºå¸¦å‡­æ®ï¼ˆcookiesã€Authorizationå¤´ï¼‰
    allow_credentials=True,
    # å…è®¸çš„HTTPæ–¹æ³•
    allow_methods=["*"],
    # å…è®¸çš„è¯·æ±‚å¤´
    allow_headers=["*"],
    # é¢„æ£€è¯·æ±‚çš„ç¼“å­˜æ—¶é—´
    max_age=600,
)
```

### 5.2 é«˜çº§ä¸­é—´ä»¶ï¼šé™æµ

é™æµæ˜¯ä¿æŠ¤APIçš„é‡è¦æ‰‹æ®µï¼Œé˜²æ­¢æ»¥ç”¨å’ŒDDoSæ”»å‡»ï¼š

```python
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response, JSONResponse
from collections import defaultdict
import time
import asyncio

class RateLimitMiddleware(BaseHTTPMiddleware):
    """
    é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶

    å®ç°æ»‘åŠ¨çª—å£é™æµç®—æ³•ï¼š
    - è®°å½•æ¯ä¸ªIPçš„è¯·æ±‚æ—¶é—´æˆ³
    - åªä¿ç•™æ—¶é—´çª—å£å†…çš„è®°å½•
    - è¶…è¿‡é™åˆ¶è¿”å›429

    æ³¨æ„ï¼šè¿™æ˜¯ç®€åŒ–å®ç°ï¼Œç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨Redis
    """

    def __init__(
        self,
        app,
        requests_per_minute: int = 60,
        window_size: int = 60
    ):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.window_size = window_size
        # å­˜å‚¨è¯·æ±‚è®°å½•ï¼š{ip: [timestamp1, timestamp2, ...]}
        self.requests: dict[str, list[float]] = defaultdict(list)
        # ç”¨äºæ¸…ç†è¿‡æœŸè®°å½•
        self._cleanup_lock = asyncio.Lock()

    async def dispatch(self, request: Request, call_next) -> Response:
        # è·å–å®¢æˆ·ç«¯IP
        # æ³¨æ„ï¼šå¦‚æœåœ¨åå‘ä»£ç†åé¢ï¼Œåº”è¯¥ä»X-Forwarded-Forè·å–
        client_ip = request.client.host
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            client_ip = forwarded_for.split(",")[0].strip()

        current_time = time.time()

        # æ¸…ç†è¿‡æœŸè®°å½•ï¼ˆé¿å…å†…å­˜æ³„æ¼ï¼‰
        async with self._cleanup_lock:
            if client_ip in self.requests:
                # åªä¿ç•™çª—å£å†…çš„è¯·æ±‚
                self.requests[client_ip] = [
                    t for t in self.requests[client_ip]
                    if current_time - t < self.window_size
                ]

        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        recent_requests = self.requests[client_ip]
        if len(recent_requests) >= self.requests_per_minute:
            # è®¡ç®—é‡è¯•æ—¶é—´
            oldest_request = min(recent_requests)
            retry_after = int(self.window_size - (current_time - oldest_request))

            return JSONResponse(
                status_code=429,
                content={
                    "error": "Too Many Requests",
                    "detail": f"è¶…è¿‡é€Ÿç‡é™åˆ¶ï¼ˆ{self.requests_per_minute}æ¬¡/åˆ†é’Ÿï¼‰",
                    "retry_after": retry_after
                },
                headers={"Retry-After": str(retry_after)}
            )

        # è®°å½•æœ¬æ¬¡è¯·æ±‚
        self.requests[client_ip].append(current_time)

        # å¤„ç†è¯·æ±‚
        response = await call_next(request)

        # æ·»åŠ é™æµä¿¡æ¯åˆ°å“åº”å¤´
        response.headers["X-RateLimit-Limit"] = str(self.requests_per_minute)
        response.headers["X-RateLimit-Remaining"] = str(
            self.requests_per_minute - len(self.requests[client_ip])
        )

        return response


# æ·»åŠ ä¸­é—´ä»¶
app.add_middleware(RateLimitMiddleware, requests_per_minute=100)
```

### 5.3 ä¸­é—´ä»¶ vs ä¾èµ–æ³¨å…¥ï¼šå¦‚ä½•é€‰æ‹©ï¼Ÿ

è¿™æ˜¯ä¸€ä¸ªå¸¸è§çš„è®¾è®¡å†³ç­–ã€‚ä¸¤è€…çš„åŒºåˆ«ï¼š

| ç‰¹æ€§ | ä¸­é—´ä»¶ | ä¾èµ–æ³¨å…¥ |
|------|--------|----------|
| æ‰§è¡ŒèŒƒå›´ | æ‰€æœ‰è¯·æ±‚ | æŒ‡å®šè·¯ç”± |
| è®¿é—®å“åº” | âœ“ å¯ä»¥ | âœ— ä¸èƒ½ |
| è¿”å›æ—©æœŸå“åº” | âœ“ å¯ä»¥ | âœ“ å¯ä»¥ï¼ˆæŠ›å¼‚å¸¸ï¼‰ |
| ä¿®æ”¹å“åº”å¤´ | âœ“ å¯ä»¥ | âœ— ä¸èƒ½ |
| æµ‹è¯•ä¾¿åˆ©æ€§ | ä¸­ç­‰ | ä¼˜ç§€ï¼ˆæ˜“äºmockï¼‰ |
| å…¸å‹ç”¨é€” | æ—¥å¿—ã€CORSã€é™æµ | è®¤è¯ã€æ•°æ®åº“ã€å‚æ•°éªŒè¯ |

**é€‰æ‹©å»ºè®®**ï¼š

```python
# ä½¿ç”¨ä¸­é—´ä»¶ï¼šéœ€è¦å¤„ç†æ‰€æœ‰è¯·æ±‚ï¼Œæˆ–éœ€è¦ä¿®æ”¹å“åº”
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    return response

# ä½¿ç”¨ä¾èµ–æ³¨å…¥ï¼šåªéœ€è¦å¤„ç†ç‰¹å®šè·¯ç”±ï¼Œæˆ–éœ€è¦å¤æ‚çš„ä¾èµ–å…³ç³»
@app.get("/protected")
async def protected_route(user: User = Depends(get_current_user)):
    return {"user": user.username}
```

---

## 6. è®¤è¯ä¸å®‰å…¨

### 6.1 ç†è§£OAuth2

OAuth2æ˜¯ç°ä»£Webè®¤è¯çš„æ ‡å‡†åè®®ã€‚FastAPIå†…ç½®äº†å®Œæ•´çš„OAuth2æ”¯æŒã€‚

**OAuth2 Password Flowçš„å·¥ä½œåŸç†**ï¼š

```
1. ç”¨æˆ·æäº¤ç”¨æˆ·åå’Œå¯†ç 
2. æœåŠ¡å™¨éªŒè¯å‡­æ®
3. éªŒè¯æˆåŠŸï¼ŒæœåŠ¡å™¨è¿”å›JWT token
4. åç»­è¯·æ±‚æºå¸¦token
5. æœåŠ¡å™¨éªŒè¯tokenï¼Œè·å–ç”¨æˆ·èº«ä»½
```

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Annotated
from pydantic import BaseModel

# ===== é…ç½® =====
SECRET_KEY = "your-secret-key-keep-it-secret"  # ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ç¯å¢ƒå˜é‡
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# ===== å¯†ç å“ˆå¸Œ =====
# ä½¿ç”¨bcryptç®—æ³•ï¼Œè¿™æ˜¯ç›®å‰æ¨èçš„å¯†ç å“ˆå¸Œç®—æ³•
# ç‰¹ç‚¹ï¼šæ…¢ï¼ˆæ•…æ„çš„ï¼Œé˜²æ­¢æš´åŠ›ç ´è§£ï¼‰ã€è‡ªåŠ¨åŠ ç›
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ===== OAuth2é…ç½® =====
# tokenUrlæ˜¯è·å–tokençš„è·¯å¾„ï¼Œç”¨äºSwagger UIçš„è®¤è¯è¡¨å•
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


# ===== æ•°æ®æ¨¡å‹ =====
class Token(BaseModel):
    """Tokenå“åº”æ¨¡å‹"""
    access_token: str
    token_type: str
    expires_in: int  # tokenæœ‰æ•ˆæœŸï¼ˆç§’ï¼‰

class TokenData(BaseModel):
    """Tokenè§£æåçš„æ•°æ®"""
    user_id: int | None = None
    username: str | None = None

class User(BaseModel):
    """ç”¨æˆ·æ¨¡å‹"""
    id: int
    username: str
    email: str
    is_active: bool = True

class UserInDB(User):
    """æ•°æ®åº“ä¸­çš„ç”¨æˆ·ï¼ˆåŒ…å«å¯†ç å“ˆå¸Œï¼‰"""
    hashed_password: str


# ===== å¯†ç å·¥å…·å‡½æ•° =====
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    éªŒè¯å¯†ç 

    ä¸ºä»€ä¹ˆä¸ç›´æ¥æ¯”è¾ƒï¼Ÿ
    - å¯†ç å­˜å‚¨çš„æ˜¯å“ˆå¸Œå€¼ï¼Œä¸æ˜¯æ˜æ–‡
    - éœ€è¦ç”¨ç›¸åŒçš„ç®—æ³•å¤„ç†è¾“å…¥çš„å¯†ç ï¼Œå†æ¯”è¾ƒå“ˆå¸Œ
    """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """
    ç”Ÿæˆå¯†ç å“ˆå¸Œ

    bcryptçš„ç‰¹ç‚¹ï¼š
    - è‡ªåŠ¨ç”Ÿæˆéšæœºç›
    - ç›å­˜å‚¨åœ¨å“ˆå¸Œç»“æœä¸­
    - æ¯æ¬¡å“ˆå¸Œç»“æœä¸åŒï¼ˆå› ä¸ºç›ä¸åŒï¼‰ï¼Œä½†éªŒè¯æ—¶éƒ½èƒ½é€šè¿‡
    """
    return pwd_context.hash(password)


# ===== JWTå·¥å…·å‡½æ•° =====
def create_access_token(
    data: dict,
    expires_delta: timedelta | None = None
) -> str:
    """
    åˆ›å»ºJWTè®¿é—®ä»¤ç‰Œ

    JWTç»“æ„ï¼šheader.payload.signature
    - header: ç®—æ³•å’Œç±»å‹
    - payload: ç”¨æˆ·æ•°æ®ï¼ˆä¸è¦æ”¾æ•æ„Ÿä¿¡æ¯ï¼ï¼‰
    - signature: ç­¾åï¼Œé˜²æ­¢ç¯¡æ”¹
    """
    to_encode = data.copy()

    # è®¾ç½®è¿‡æœŸæ—¶é—´
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow(),  # ç­¾å‘æ—¶é—´
        "type": "access"           # ä»¤ç‰Œç±»å‹
    })

    # ç”ŸæˆJWT
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


# ===== ç”¨æˆ·è®¤è¯ä¾èµ– =====
async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)]
) -> User:
    """
    ä»tokenè·å–å½“å‰ç”¨æˆ·

    è¿™æ˜¯æ ¸å¿ƒè®¤è¯é€»è¾‘ï¼Œè¢«å…¶ä»–éœ€è¦è®¤è¯çš„è·¯ç”±ä¾èµ–
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="æ— æ³•éªŒè¯å‡­æ®",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        # è§£ç JWT
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # æå–ç”¨æˆ·ä¿¡æ¯
        username: str = payload.get("sub")
        user_id: int = payload.get("user_id")

        if username is None:
            raise credentials_exception

        token_data = TokenData(username=username, user_id=user_id)

    except JWTError as e:
        # JWTè§£ç å¤±è´¥ï¼ˆè¿‡æœŸã€ç­¾åæ— æ•ˆç­‰ï¼‰
        raise credentials_exception

    # ä»æ•°æ®åº“è·å–ç”¨æˆ·ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿï¼‰
    user = get_user_from_db(token_data.user_id)
    if user is None:
        raise credentials_exception

    return user


# ===== ç™»å½•ç«¯ç‚¹ =====
@app.post("/token", response_model=Token)
async def login(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    ç”¨æˆ·ç™»å½•ï¼Œè·å–è®¿é—®ä»¤ç‰Œ

    OAuth2PasswordRequestFormæ˜¯æ ‡å‡†çš„OAuth2å¯†ç æµè¡¨å•ï¼š
    - username: ç”¨æˆ·å
    - password: å¯†ç 
    - scope: æƒé™èŒƒå›´ï¼ˆå¯é€‰ï¼‰
    """
    # 1. éªŒè¯ç”¨æˆ·å‡­æ®
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 2. åˆ›å»ºè®¿é—®ä»¤ç‰Œ
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={
            "sub": user.username,
            "user_id": user.id
        },
        expires_delta=access_token_expires
    )

    # 3. è¿”å›ä»¤ç‰Œ
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )


# ===== å—ä¿æŠ¤çš„ç«¯ç‚¹ =====
@app.get("/users/me", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_user)]
):
    """
    è·å–å½“å‰ç™»å½•ç”¨æˆ·ä¿¡æ¯

    ç”±äºä¾èµ–get_current_userï¼Œæœªè®¤è¯çš„è¯·æ±‚ä¼šè¿”å›401
    """
    return current_user
```

### 6.2 åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰

å®é™…åº”ç”¨é€šå¸¸éœ€è¦æ›´ç»†ç²’åº¦çš„æƒé™æ§åˆ¶ï¼š

```python
from enum import Enum
from functools import wraps

class Permission(str, Enum):
    """æƒé™æšä¸¾"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"

class Role(str, Enum):
    """è§’è‰²æšä¸¾"""
    VIEWER = "viewer"
    EDITOR = "editor"
    ADMIN = "admin"

# è§’è‰²-æƒé™æ˜ å°„
ROLE_PERMISSIONS = {
    Role.VIEWER: [Permission.READ],
    Role.EDITOR: [Permission.READ, Permission.WRITE],
    Role.ADMIN: [Permission.READ, Permission.WRITE, Permission.DELETE, Permission.ADMIN],
}


class User(BaseModel):
    id: int
    username: str
    role: Role


def require_permissions(*required_permissions: Permission):
    """
    æƒé™æ£€æŸ¥ä¾èµ–å·¥å‚

    ä½¿ç”¨æ–¹å¼ï¼š
    @app.delete("/items/{id}")
    async def delete_item(
        id: int,
        user: User = Depends(require_permissions(Permission.DELETE))
    ):
        ...
    """
    async def permission_checker(
        current_user: Annotated[User, Depends(get_current_user)]
    ) -> User:
        # è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™
        user_permissions = ROLE_PERMISSIONS.get(current_user.role, [])

        # æ£€æŸ¥æ˜¯å¦æ‹¥æœ‰æ‰€éœ€æƒé™
        for perm in required_permissions:
            if perm not in user_permissions:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"éœ€è¦ {perm.value} æƒé™"
                )

        return current_user

    return permission_checker


# ä½¿ç”¨ç¤ºä¾‹
@app.get("/articles")
async def list_articles(
    user: User = Depends(require_permissions(Permission.READ))
):
    """ä»»ä½•è§’è‰²éƒ½å¯ä»¥è¯»å–"""
    return {"articles": [...]}

@app.post("/articles")
async def create_article(
    article: Article,
    user: User = Depends(require_permissions(Permission.WRITE))
):
    """éœ€è¦å†™å…¥æƒé™"""
    return {"created": article}

@app.delete("/articles/{id}")
async def delete_article(
    id: int,
    user: User = Depends(require_permissions(Permission.DELETE))
):
    """éœ€è¦åˆ é™¤æƒé™ï¼ˆåªæœ‰ç®¡ç†å‘˜ï¼‰"""
    return {"deleted": id}
```

---

## 7. æ•°æ®åº“é›†æˆ

### 7.1 SQLAlchemyå¼‚æ­¥é›†æˆ

ç°ä»£FastAPIåº”ç”¨æ¨èä½¿ç”¨å¼‚æ­¥æ•°æ®åº“æ“ä½œã€‚SQLAlchemy 2.0å®Œå…¨æ”¯æŒasync/awaitï¼š

```python
from sqlalchemy.ext.asyncio import (
    create_async_engine,
    AsyncSession,
    async_sessionmaker
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from sqlalchemy import String, ForeignKey, select
from datetime import datetime
from typing import AsyncGenerator

# ===== æ•°æ®åº“é…ç½® =====
# å¼‚æ­¥PostgreSQLè¿æ¥éœ€è¦ä½¿ç”¨asyncpgé©±åŠ¨
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"

# åˆ›å»ºå¼‚æ­¥å¼•æ“
engine = create_async_engine(
    DATABASE_URL,
    echo=True,           # å¼€å‘ç¯å¢ƒæ‰“å°SQLï¼Œç”Ÿäº§ç¯å¢ƒå…³é—­
    pool_size=10,        # è¿æ¥æ± å¤§å°
    max_overflow=20,     # è¶…å‡ºpool_sizeæ—¶å¯é¢å¤–åˆ›å»ºçš„è¿æ¥æ•°
    pool_recycle=3600,   # è¿æ¥å›æ”¶æ—¶é—´ï¼Œé˜²æ­¢æ•°æ®åº“æ–­å¼€ç©ºé—²è¿æ¥
    pool_pre_ping=True,  # ä½¿ç”¨å‰æ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
)

# åˆ›å»ºä¼šè¯å·¥å‚
async_session = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False  # æäº¤åä¸è¿‡æœŸå¯¹è±¡ï¼Œé¿å…é¢å¤–æŸ¥è¯¢
)


# ===== æ¨¡å‹å®šä¹‰ =====
class Base(DeclarativeBase):
    """æ‰€æœ‰æ¨¡å‹çš„åŸºç±»"""
    pass


class User(Base):
    """
    ç”¨æˆ·æ¨¡å‹

    SQLAlchemy 2.0ä½¿ç”¨Mappedå’Œmapped_columnè¿›è¡Œç±»å‹å®‰å…¨çš„å®šä¹‰
    """
    __tablename__ = "users"

    # ä¸»é”®
    id: Mapped[int] = mapped_column(primary_key=True)

    # å”¯ä¸€ç´¢å¼•åˆ—
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True)
    email: Mapped[str] = mapped_column(String(100), unique=True)

    # æ™®é€šåˆ—
    hashed_password: Mapped[str] = mapped_column(String(255))
    is_active: Mapped[bool] = mapped_column(default=True)

    # å¸¦é»˜è®¤å€¼çš„æ—¶é—´æˆ³
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    updated_at: Mapped[datetime | None] = mapped_column(
        default=None,
        onupdate=datetime.utcnow
    )


class Article(Base):
    """æ–‡ç« æ¨¡å‹"""
    __tablename__ = "articles"

    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200))
    content: Mapped[str] = mapped_column()  # TEXTç±»å‹

    # å¤–é”®å…³è”
    author_id: Mapped[int] = mapped_column(ForeignKey("users.id"))

    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)


# ===== æ•°æ®åº“ä¼šè¯ä¾èµ– =====
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    æ•°æ®åº“ä¼šè¯ä¾èµ–

    ä½¿ç”¨async withç¡®ä¿ä¼šè¯æ­£ç¡®å…³é—­
    ä½¿ç”¨try/exceptå¤„ç†å¼‚å¸¸æ—¶çš„å›æ»š
    """
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

### 7.2 CRUDæ“ä½œæ¨¡å¼

ç»„ç»‡è‰¯å¥½çš„CRUDæ“ä½œå¯ä»¥æé«˜ä»£ç å¤ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§ï¼š

```python
from sqlalchemy import select, update, delete
from sqlalchemy.ext.asyncio import AsyncSession
from typing import TypeVar, Generic
from pydantic import BaseModel

# æ³›å‹ç±»å‹
ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    """
    é€šç”¨CRUDåŸºç±»

    æä¾›æ ‡å‡†çš„å¢åˆ æ”¹æŸ¥æ“ä½œï¼Œå­ç±»å¯ä»¥ç»§æ‰¿å¹¶æ‰©å±•
    """

    def __init__(self, model: type[ModelType]):
        self.model = model

    async def get(
        self,
        db: AsyncSession,
        id: int
    ) -> ModelType | None:
        """æ ¹æ®IDè·å–å•ä¸ªè®°å½•"""
        result = await db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()

    async def get_multi(
        self,
        db: AsyncSession,
        *,
        skip: int = 0,
        limit: int = 100
    ) -> list[ModelType]:
        """è·å–å¤šæ¡è®°å½•ï¼Œæ”¯æŒåˆ†é¡µ"""
        result = await db.execute(
            select(self.model)
            .offset(skip)
            .limit(limit)
            .order_by(self.model.id.desc())
        )
        return list(result.scalars().all())

    async def create(
        self,
        db: AsyncSession,
        *,
        obj_in: CreateSchemaType
    ) -> ModelType:
        """åˆ›å»ºæ–°è®°å½•"""
        # å°†Pydanticæ¨¡å‹è½¬æ¢ä¸ºå­—å…¸
        obj_in_data = obj_in.model_dump()
        # åˆ›å»ºæ•°æ®åº“æ¨¡å‹å®ä¾‹
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        # flushå°†å¯¹è±¡æŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼Œä½†ä¸æäº¤äº‹åŠ¡
        await db.flush()
        # refreshè·å–æ•°æ®åº“ç”Ÿæˆçš„å€¼ï¼ˆå¦‚è‡ªå¢IDï¼‰
        await db.refresh(db_obj)
        return db_obj

    async def update(
        self,
        db: AsyncSession,
        *,
        db_obj: ModelType,
        obj_in: UpdateSchemaType | dict
    ) -> ModelType:
        """æ›´æ–°è®°å½•"""
        # å¤„ç†è¾“å…¥æ•°æ®
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)

        # æ›´æ–°å¯¹è±¡å±æ€§
        for field, value in update_data.items():
            if hasattr(db_obj, field):
                setattr(db_obj, field, value)

        db.add(db_obj)
        await db.flush()
        await db.refresh(db_obj)
        return db_obj

    async def delete(
        self,
        db: AsyncSession,
        *,
        id: int
    ) -> bool:
        """åˆ é™¤è®°å½•"""
        result = await db.execute(
            delete(self.model).where(self.model.id == id)
        )
        return result.rowcount > 0


# ===== ç”¨æˆ·CRUD =====
class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserUpdate(BaseModel):
    username: str | None = None
    email: str | None = None
    is_active: bool | None = None


class CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):
    """
    ç”¨æˆ·CRUDæ“ä½œ

    ç»§æ‰¿é€šç”¨CRUDï¼Œæ·»åŠ ç”¨æˆ·ç‰¹å®šçš„æ“ä½œ
    """

    async def get_by_email(
        self,
        db: AsyncSession,
        email: str
    ) -> User | None:
        """æ ¹æ®é‚®ç®±è·å–ç”¨æˆ·"""
        result = await db.execute(
            select(User).where(User.email == email)
        )
        return result.scalar_one_or_none()

    async def get_by_username(
        self,
        db: AsyncSession,
        username: str
    ) -> User | None:
        """æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·"""
        result = await db.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()

    async def create(
        self,
        db: AsyncSession,
        *,
        obj_in: UserCreate
    ) -> User:
        """åˆ›å»ºç”¨æˆ·ï¼ˆå¯†ç éœ€è¦å“ˆå¸Œï¼‰"""
        db_obj = User(
            username=obj_in.username,
            email=obj_in.email,
            hashed_password=get_password_hash(obj_in.password)
        )
        db.add(db_obj)
        await db.flush()
        await db.refresh(db_obj)
        return db_obj

    async def authenticate(
        self,
        db: AsyncSession,
        *,
        username: str,
        password: str
    ) -> User | None:
        """éªŒè¯ç”¨æˆ·å‡­æ®"""
        user = await self.get_by_username(db, username)
        if not user:
            return None
        if not verify_password(password, user.hashed_password):
            return None
        return user


# åˆ›å»ºCRUDå®ä¾‹
user_crud = CRUDUser(User)


# ===== åœ¨è·¯ç”±ä¸­ä½¿ç”¨ =====
@app.post("/users/", response_model=UserResponse)
async def create_user(
    user_in: UserCreate,
    db: Annotated[AsyncSession, Depends(get_db)]
):
    """åˆ›å»ºæ–°ç”¨æˆ·"""
    # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    existing = await user_crud.get_by_username(db, user_in.username)
    if existing:
        raise HTTPException(
            status_code=400,
            detail="ç”¨æˆ·åå·²è¢«ä½¿ç”¨"
        )

    # æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    existing = await user_crud.get_by_email(db, user_in.email)
    if existing:
        raise HTTPException(
            status_code=400,
            detail="é‚®ç®±å·²è¢«ä½¿ç”¨"
        )

    # åˆ›å»ºç”¨æˆ·
    user = await user_crud.create(db, obj_in=user_in)
    return user
```

---

## 8. åå°ä»»åŠ¡ä¸WebSocket

### 8.1 åå°ä»»åŠ¡

æœ‰äº›æ“ä½œä¸éœ€è¦è®©ç”¨æˆ·ç­‰å¾…ï¼Œæ¯”å¦‚å‘é€é‚®ä»¶ã€ç”ŸæˆæŠ¥å‘Šç­‰ã€‚FastAPIæä¾›äº†ç®€å•çš„åå°ä»»åŠ¡æœºåˆ¶ï¼š

```python
from fastapi import BackgroundTasks
from typing import Annotated

def write_log(message: str):
    """
    å†™æ—¥å¿—çš„åå°ä»»åŠ¡

    è¿™ä¸ªå‡½æ•°ä¼šåœ¨å“åº”å‘é€åæ‰§è¡Œ
    å³ä½¿å®ƒæ‰§è¡Œå¾ˆæ…¢ï¼Œä¹Ÿä¸ä¼šå½±å“å“åº”æ—¶é—´
    """
    with open("log.txt", "a") as f:
        f.write(f"{datetime.now()}: {message}\n")

async def send_email_async(email: str, subject: str, body: str):
    """
    å¼‚æ­¥å‘é€é‚®ä»¶

    åå°ä»»åŠ¡ä¹Ÿå¯ä»¥æ˜¯asyncå‡½æ•°
    """
    # æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    await asyncio.sleep(2)
    print(f"é‚®ä»¶å·²å‘é€åˆ° {email}")


@app.post("/users/")
async def create_user(
    user: UserCreate,
    background_tasks: BackgroundTasks,
    db: Annotated[AsyncSession, Depends(get_db)]
):
    """
    åˆ›å»ºç”¨æˆ·å¹¶å‘é€æ¬¢è¿é‚®ä»¶

    é‚®ä»¶å‘é€åœ¨åå°è¿›è¡Œï¼Œç”¨æˆ·æ— éœ€ç­‰å¾…
    """
    # åˆ›å»ºç”¨æˆ·
    new_user = await user_crud.create(db, obj_in=user)

    # æ·»åŠ åå°ä»»åŠ¡
    # æ³¨æ„ï¼šè¿™åªæ˜¯æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œä¸ä¼šç«‹å³æ‰§è¡Œ
    background_tasks.add_task(
        send_email_async,
        email=user.email,
        subject="æ¬¢è¿åŠ å…¥ï¼",
        body=f"ä½ å¥½ {user.username}ï¼Œæ¬¢è¿ä½¿ç”¨æˆ‘ä»¬çš„æœåŠ¡ï¼"
    )

    # æ·»åŠ å¤šä¸ªåå°ä»»åŠ¡
    background_tasks.add_task(write_log, f"æ–°ç”¨æˆ·æ³¨å†Œ: {user.username}")

    # ç«‹å³è¿”å›å“åº”ï¼Œåå°ä»»åŠ¡ç¨åæ‰§è¡Œ
    return new_user
```

**åå°ä»»åŠ¡çš„é™åˆ¶**ï¼š

åå°ä»»åŠ¡é€‚åˆç®€å•ã€å¿«é€Ÿçš„æ“ä½œã€‚å¯¹äºä»¥ä¸‹æƒ…å†µï¼Œåº”è¯¥ä½¿ç”¨ä¸“é—¨çš„ä»»åŠ¡é˜Ÿåˆ—ï¼ˆå¦‚Celeryï¼‰ï¼š
- æ‰§è¡Œæ—¶é—´å¾ˆé•¿ï¼ˆå‡ åˆ†é’Ÿç”šè‡³å‡ å°æ—¶ï¼‰
- éœ€è¦é‡è¯•æœºåˆ¶
- éœ€è¦ä»»åŠ¡çŠ¶æ€è¿½è¸ª
- éœ€è¦åœ¨å¤šä¸ªæœåŠ¡å™¨é—´åˆ†å¸ƒæ‰§è¡Œ

### 8.2 WebSocketå®æ—¶é€šä¿¡

WebSocketæä¾›äº†å…¨åŒå·¥é€šä¿¡èƒ½åŠ›ï¼Œé€‚åˆèŠå¤©ã€é€šçŸ¥ã€å®æ—¶æ•°æ®ç­‰åœºæ™¯ï¼š

```python
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, List
import json

class ConnectionManager:
    """
    WebSocketè¿æ¥ç®¡ç†å™¨

    èŒè´£ï¼š
    - ç»´æŠ¤æ´»è·ƒè¿æ¥åˆ—è¡¨
    - ç®¡ç†è¿æ¥çš„åŠ å…¥å’Œæ–­å¼€
    - æä¾›å¹¿æ’­å’Œå®šå‘å‘é€èƒ½åŠ›
    """

    def __init__(self):
        # æŒ‰æˆ¿é—´ç»„ç»‡è¿æ¥
        self.active_connections: Dict[str, List[WebSocket]] = {}
        # è¿æ¥åˆ°ç”¨æˆ·çš„æ˜ å°„
        self.connection_users: Dict[WebSocket, dict] = {}

    async def connect(
        self,
        websocket: WebSocket,
        room: str,
        user_info: dict
    ):
        """
        å»ºç«‹è¿æ¥

        è¿æ¥å»ºç«‹æµç¨‹ï¼š
        1. æ¥å—WebSocketæ¡æ‰‹
        2. å°†è¿æ¥æ·»åŠ åˆ°æˆ¿é—´
        3. è®°å½•ç”¨æˆ·ä¿¡æ¯
        """
        await websocket.accept()

        if room not in self.active_connections:
            self.active_connections[room] = []

        self.active_connections[room].append(websocket)
        self.connection_users[websocket] = user_info

        # å¹¿æ’­åŠ å…¥æ¶ˆæ¯
        await self.broadcast_to_room(
            room,
            {
                "type": "system",
                "message": f"{user_info['username']} åŠ å…¥äº†æˆ¿é—´"
            },
            exclude=websocket
        )

    def disconnect(self, websocket: WebSocket, room: str):
        """æ–­å¼€è¿æ¥"""
        if room in self.active_connections:
            self.active_connections[room].remove(websocket)
            if not self.active_connections[room]:
                del self.active_connections[room]

        user_info = self.connection_users.pop(websocket, {})
        return user_info

    async def send_personal(self, websocket: WebSocket, data: dict):
        """å‘é€ç§äººæ¶ˆæ¯"""
        await websocket.send_json(data)

    async def broadcast_to_room(
        self,
        room: str,
        data: dict,
        exclude: WebSocket | None = None
    ):
        """
        å¹¿æ’­æ¶ˆæ¯åˆ°æˆ¿é—´å†…æ‰€æœ‰è¿æ¥

        excludeå‚æ•°ç”¨äºæ’é™¤å‘é€è€…è‡ªå·±
        """
        for connection in self.active_connections.get(room, []):
            if connection != exclude:
                try:
                    await connection.send_json(data)
                except:
                    # è¿æ¥å¯èƒ½å·²æ–­å¼€
                    pass

    def get_room_users(self, room: str) -> List[str]:
        """è·å–æˆ¿é—´å†…çš„ç”¨æˆ·åˆ—è¡¨"""
        users = []
        for conn in self.active_connections.get(room, []):
            if conn in self.connection_users:
                users.append(self.connection_users[conn]['username'])
        return users


manager = ConnectionManager()


@app.websocket("/ws/chat/{room}")
async def websocket_endpoint(
    websocket: WebSocket,
    room: str,
    token: str  # é€šè¿‡æŸ¥è¯¢å‚æ•°ä¼ é€’token
):
    """
    èŠå¤©å®¤WebSocketç«¯ç‚¹

    è¿æ¥URLç¤ºä¾‹: ws://localhost:8000/ws/chat/general?token=xxx
    """
    # éªŒè¯token
    try:
        user = await verify_token(token)
    except Exception:
        await websocket.close(code=4001, reason="è®¤è¯å¤±è´¥")
        return

    user_info = {"username": user.username, "id": user.id}

    # å»ºç«‹è¿æ¥
    await manager.connect(websocket, room, user_info)

    # å‘é€æˆ¿é—´ä¿¡æ¯
    await manager.send_personal(websocket, {
        "type": "room_info",
        "room": room,
        "users": manager.get_room_users(room)
    })

    try:
        while True:
            # æ¥æ”¶æ¶ˆæ¯
            data = await websocket.receive_json()

            # å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
            msg_type = data.get("type", "message")

            if msg_type == "message":
                # å¹¿æ’­èŠå¤©æ¶ˆæ¯
                await manager.broadcast_to_room(room, {
                    "type": "message",
                    "username": user.username,
                    "content": data.get("content", ""),
                    "timestamp": datetime.now().isoformat()
                })

            elif msg_type == "typing":
                # å¹¿æ’­æ­£åœ¨è¾“å…¥çŠ¶æ€
                await manager.broadcast_to_room(room, {
                    "type": "typing",
                    "username": user.username
                }, exclude=websocket)

    except WebSocketDisconnect:
        # å¤„ç†æ–­å¼€è¿æ¥
        user_info = manager.disconnect(websocket, room)
        await manager.broadcast_to_room(room, {
            "type": "system",
            "message": f"{user_info.get('username', 'Unknown')} ç¦»å¼€äº†æˆ¿é—´"
        })
```

---

## 9. æµ‹è¯•ç­–ç•¥

### 9.1 æµ‹è¯•çš„é‡è¦æ€§

å¥½çš„æµ‹è¯•æ˜¯é«˜è´¨é‡è½¯ä»¶çš„åŸºçŸ³ã€‚FastAPIçš„è®¾è®¡è®©æµ‹è¯•å˜å¾—éå¸¸ç®€å•ï¼š

```python
# test_main.py
from fastapi.testclient import TestClient
from main import app

# TestClientä½¿ç”¨requestsåº“ï¼Œæä¾›åŒæ­¥çš„æµ‹è¯•æ¥å£
client = TestClient(app)


class TestUserAPI:
    """ç”¨æˆ·APIæµ‹è¯•"""

    def test_create_user_success(self):
        """æµ‹è¯•æˆåŠŸåˆ›å»ºç”¨æˆ·"""
        response = client.post(
            "/users/",
            json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "TestPass123"
            }
        )

        assert response.status_code == 200
        data = response.json()
        assert data["username"] == "testuser"
        assert data["email"] == "test@example.com"
        assert "password" not in data  # ç¡®ä¿å¯†ç ä¸è¿”å›
        assert "id" in data  # ç¡®ä¿è¿”å›äº†ID

    def test_create_user_invalid_email(self):
        """æµ‹è¯•é‚®ç®±æ ¼å¼æ— æ•ˆ"""
        response = client.post(
            "/users/",
            json={
                "username": "testuser",
                "email": "invalid-email",  # æ— æ•ˆé‚®ç®±
                "password": "TestPass123"
            }
        )

        assert response.status_code == 422  # éªŒè¯é”™è¯¯
        error = response.json()
        assert "detail" in error

    def test_create_user_weak_password(self):
        """æµ‹è¯•å¼±å¯†ç """
        response = client.post(
            "/users/",
            json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "weak"  # å¤ªçŸ­
            }
        )

        assert response.status_code == 422

    def test_get_user_not_found(self):
        """æµ‹è¯•ç”¨æˆ·ä¸å­˜åœ¨"""
        response = client.get("/users/99999")
        assert response.status_code == 404


class TestAuthentication:
    """è®¤è¯æµ‹è¯•"""

    def test_login_success(self):
        """æµ‹è¯•ç™»å½•æˆåŠŸ"""
        # å…ˆåˆ›å»ºç”¨æˆ·
        client.post("/users/", json={
            "username": "loginuser",
            "email": "login@example.com",
            "password": "TestPass123"
        })

        # ç™»å½•
        response = client.post(
            "/token",
            data={  # OAuth2ä½¿ç”¨form data
                "username": "loginuser",
                "password": "TestPass123"
            }
        )

        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"

    def test_login_wrong_password(self):
        """æµ‹è¯•å¯†ç é”™è¯¯"""
        response = client.post(
            "/token",
            data={
                "username": "loginuser",
                "password": "WrongPassword"
            }
        )

        assert response.status_code == 401

    def test_protected_route_without_token(self):
        """æµ‹è¯•æœªè®¤è¯è®¿é—®å—ä¿æŠ¤è·¯ç”±"""
        response = client.get("/users/me")
        assert response.status_code == 401

    def test_protected_route_with_token(self):
        """æµ‹è¯•è®¤è¯åè®¿é—®å—ä¿æŠ¤è·¯ç”±"""
        # ç™»å½•è·å–token
        login_response = client.post(
            "/token",
            data={"username": "loginuser", "password": "TestPass123"}
        )
        token = login_response.json()["access_token"]

        # ä½¿ç”¨tokenè®¿é—®
        response = client.get(
            "/users/me",
            headers={"Authorization": f"Bearer {token}"}
        )

        assert response.status_code == 200
        assert response.json()["username"] == "loginuser"
```

### 9.2 ä¾èµ–æ³¨å…¥è¦†ç›–

æµ‹è¯•æ—¶ç»å¸¸éœ€è¦æ›¿æ¢çœŸå®ä¾èµ–ï¼Œæ¯”å¦‚ä½¿ç”¨æµ‹è¯•æ•°æ®åº“ï¼š

```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from main import app, get_db, Base

# ===== æµ‹è¯•æ•°æ®åº“é…ç½® =====
# ä½¿ç”¨å†…å­˜SQLiteï¼Œæ¯æ¬¡æµ‹è¯•éƒ½æ˜¯å¹²å‡€çš„
TEST_DATABASE_URL = "sqlite:///:memory:"

engine = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool  # ä¿æŒå•ä¸€è¿æ¥
)

TestingSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)


@pytest.fixture(scope="function")
def db_session():
    """
    æ•°æ®åº“ä¼šè¯fixture

    æ¯ä¸ªæµ‹è¯•å‡½æ•°éƒ½ä¼šï¼š
    1. åˆ›å»ºå…¨æ–°çš„è¡¨
    2. è·å¾—ç‹¬ç«‹çš„æ•°æ®åº“ä¼šè¯
    3. æµ‹è¯•ç»“æŸååˆ é™¤æ‰€æœ‰è¡¨
    """
    # åˆ›å»ºè¡¨
    Base.metadata.create_all(bind=engine)

    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()
        # æ¸…ç†
        Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def client(db_session):
    """
    æµ‹è¯•å®¢æˆ·ç«¯fixture

    è¦†ç›–get_dbä¾èµ–ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®åº“
    """
    def override_get_db():
        try:
            yield db_session
        finally:
            pass

    # è¦†ç›–ä¾èµ–
    app.dependency_overrides[get_db] = override_get_db

    with TestClient(app) as c:
        yield c

    # æ¸…ç†è¦†ç›–
    app.dependency_overrides.clear()


def test_create_and_get_user(client):
    """
    é›†æˆæµ‹è¯•ï¼šåˆ›å»ºç”¨æˆ·å¹¶è·å–

    ä½¿ç”¨è¦†ç›–åçš„æµ‹è¯•æ•°æ®åº“
    """
    # åˆ›å»º
    response = client.post("/users/", json={
        "username": "newuser",
        "email": "new@example.com",
        "password": "Pass123456"
    })
    assert response.status_code == 200
    user_id = response.json()["id"]

    # è·å–
    response = client.get(f"/users/{user_id}")
    assert response.status_code == 200
    assert response.json()["username"] == "newuser"
```

---

## 10. ç”Ÿäº§éƒ¨ç½²ä¸æ€§èƒ½ä¼˜åŒ–

### 10.1 éƒ¨ç½²æ¶æ„

ç”Ÿäº§ç¯å¢ƒçš„å…¸å‹éƒ¨ç½²æ¶æ„ï¼š

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Nginx/Caddy   â”‚  åå‘ä»£ç†ã€SSLç»ˆæ­¢ã€é™æ€æ–‡ä»¶
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
        â”‚ Gunicorn  â”‚  â”‚ Gunicorn  â”‚  â”‚ Gunicorn  â”‚  è¿›ç¨‹ç®¡ç†
        â”‚  Worker   â”‚  â”‚  Worker   â”‚  â”‚  Worker   â”‚
        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
              â”‚              â”‚              â”‚
        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
        â”‚  Uvicorn  â”‚  â”‚  Uvicorn  â”‚  â”‚  Uvicorn  â”‚  ASGIæœåŠ¡å™¨
        â”‚ (FastAPI) â”‚  â”‚ (FastAPI) â”‚  â”‚ (FastAPI) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Uvicorné…ç½®**ï¼š

```python
# run.py
import uvicorn
from main import app

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        workers=4,              # å·¥ä½œè¿›ç¨‹æ•°
        loop="uvloop",          # æ›´å¿«çš„äº‹ä»¶å¾ªç¯
        http="httptools",       # æ›´å¿«çš„HTTPè§£æå™¨
        log_level="info",
        access_log=True,
        reload=False,           # ç”Ÿäº§ç¯å¢ƒç¦ç”¨
        proxy_headers=True,     # ä¿¡ä»»ä»£ç†å¤´
    )
```

**Gunicorn + Uvicorn**ï¼š

```bash
# gunicorn.conf.py
bind = "0.0.0.0:8000"
workers = 4                    # é€šå¸¸ä¸º CPUæ ¸å¿ƒæ•° * 2 + 1
worker_class = "uvicorn.workers.UvicornWorker"
timeout = 120                  # è¯·æ±‚è¶…æ—¶
keepalive = 5                  # Keep-aliveè¶…æ—¶
max_requests = 1000            # Workerå¤„ç†å¤šå°‘è¯·æ±‚åé‡å¯
max_requests_jitter = 50       # æ·»åŠ éšæœºæ€§ï¼Œé¿å…æ‰€æœ‰workeråŒæ—¶é‡å¯

# å¯åŠ¨å‘½ä»¤
# gunicorn main:app -c gunicorn.conf.py
```

### 10.2 Dockeréƒ¨ç½²

```dockerfile
# Dockerfile
FROM python:3.11-slim

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .

# å®‰è£…Pythonä¾èµ–
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·ï¼ˆå®‰å…¨æœ€ä½³å®è·µï¼‰
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# å¯åŠ¨å‘½ä»¤
CMD ["gunicorn", "main:app", \
     "--workers", "4", \
     "--worker-class", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000", \
     "--access-logfile", "-", \
     "--error-logfile", "-"]
```

### 10.3 æ€§èƒ½ä¼˜åŒ–

```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

# 1. ä½¿ç”¨æ›´å¿«çš„JSONåºåˆ—åŒ–å™¨
# orjsonæ¯”æ ‡å‡†jsonå¿«3-10å€
app = FastAPI(default_response_class=ORJSONResponse)

# 2. å¯ç”¨Gzipå‹ç¼©
from fastapi.middleware.gzip import GZipMiddleware
app.add_middleware(GZipMiddleware, minimum_size=1000)

# 3. æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,           # æ ¹æ®å¹¶å‘éœ€æ±‚è°ƒæ•´
    max_overflow=10,        # çªå‘æµé‡æ—¶é¢å¤–çš„è¿æ¥
    pool_timeout=30,        # ç­‰å¾…å¯ç”¨è¿æ¥çš„è¶…æ—¶æ—¶é—´
    pool_recycle=1800,      # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆé˜²æ­¢æ•°æ®åº“æ–­å¼€ï¼‰
    pool_pre_ping=True,     # ä½¿ç”¨å‰æ£€æŸ¥è¿æ¥æœ‰æ•ˆæ€§
)

# 4. å“åº”ç¼“å­˜ï¼ˆä½¿ç”¨Redisï¼‰
from fastapi_cache import FastAPICache
from fastapi_cache.backends.redis import RedisBackend
from fastapi_cache.decorator import cache

@app.on_event("startup")
async def startup():
    redis = await aioredis.from_url("redis://localhost")
    FastAPICache.init(RedisBackend(redis), prefix="api-cache")

@app.get("/expensive-data")
@cache(expire=60)  # ç¼“å­˜60ç§’
async def get_expensive_data():
    # è€—æ—¶çš„è®¡ç®—æˆ–æŸ¥è¯¢
    return {"data": result}

# 5. æ‰¹é‡æ“ä½œä»£æ›¿å¾ªç¯
@app.post("/users/batch")
async def create_users_batch(
    users: list[UserCreate],
    db: AsyncSession = Depends(get_db)
):
    # æ‰¹é‡æ’å…¥
    db_users = [User(**u.model_dump()) for u in users]
    db.add_all(db_users)
    await db.commit()
    return {"created": len(db_users)}
```

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **å¼‚æ­¥ç¼–ç¨‹**ï¼šç†è§£async/awaitçš„æœ¬è´¨ï¼Œæ­£ç¡®åŒºåˆ†I/Oå¯†é›†å’ŒCPUå¯†é›†æ“ä½œ

2. **ç±»å‹ç³»ç»Ÿ**ï¼šå……åˆ†åˆ©ç”¨Pythonç±»å‹æ³¨è§£å’ŒPydanticï¼Œè®©ä»£ç æ›´å®‰å…¨ã€æ–‡æ¡£æ›´å®Œå–„

3. **ä¾èµ–æ³¨å…¥**ï¼šè¿™æ˜¯FastAPIçš„æ ¸å¿ƒè®¾è®¡ï¼Œç”¨äºä»£ç å¤ç”¨ã€æµ‹è¯•ä¾¿åˆ©ã€å…³æ³¨ç‚¹åˆ†ç¦»

4. **ä¸­é—´ä»¶**ï¼šå¤„ç†æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼Œå¦‚æ—¥å¿—ã€CORSã€é™æµ

5. **å®‰å…¨è®¤è¯**ï¼šå®ç°OAuth2ã€JWTï¼Œä¿æŠ¤APIå®‰å…¨

6. **æ•°æ®åº“**ï¼šä½¿ç”¨å¼‚æ­¥SQLAlchemyï¼Œæ­£ç¡®ç®¡ç†è¿æ¥å’Œäº‹åŠ¡

7. **æµ‹è¯•**ï¼šç¼–å†™å…¨é¢çš„æµ‹è¯•ï¼Œä½¿ç”¨ä¾èµ–è¦†ç›–éš”ç¦»å¤–éƒ¨ä¾èµ–

8. **éƒ¨ç½²**ï¼šä½¿ç”¨Dockerå®¹å™¨åŒ–ï¼ŒGunicornç®¡ç†è¿›ç¨‹ï¼Œæ³¨æ„æ€§èƒ½ä¼˜åŒ–

### æœ€ä½³å®è·µæ¸…å•

- [ ] ä½¿ç”¨ç±»å‹æ³¨è§£å’ŒPydanticæ¨¡å‹éªŒè¯æ•°æ®
- [ ] æ­£ç¡®åŒºåˆ†async defå’Œdefçš„ä½¿ç”¨åœºæ™¯
- [ ] ä½¿ç”¨ä¾èµ–æ³¨å…¥ç®¡ç†æ•°æ®åº“ã€è®¤è¯ç­‰
- [ ] å®ç°ç»Ÿä¸€çš„å¼‚å¸¸å¤„ç†å’Œå“åº”æ ¼å¼
- [ ] ç¼–å†™æµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½
- [ ] ä½¿ç”¨ç¯å¢ƒå˜é‡ç®¡ç†é…ç½®ï¼Œä¸è¦ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯
- [ ] å®ç°æ—¥å¿—å’Œç›‘æ§
- [ ] ä½¿ç”¨Dockerå®¹å™¨åŒ–éƒ¨ç½²
- [ ] é…ç½®HTTPSå’Œå®‰å…¨å“åº”å¤´
- [ ] å®ç°é€Ÿç‡é™åˆ¶ä¿æŠ¤API

### å‚è€ƒèµ„æº

- [FastAPIå®˜æ–¹æ–‡æ¡£](https://fastapi.tiangolo.com/)
- [Pydanticå®˜æ–¹æ–‡æ¡£](https://docs.pydantic.dev/)
- [SQLAlchemyæ–‡æ¡£](https://docs.sqlalchemy.org/)
- [SQLModelæ–‡æ¡£](https://sqlmodel.tiangolo.com/)
- [Starletteæ–‡æ¡£](https://www.starlette.io/)
