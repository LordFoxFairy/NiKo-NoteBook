# 第7章 完整系统集成

## 7.1 微服务架构设计

```python
# FastAPI服务端
from fastapi import FastAPI, WebSocket
import asyncio

app = FastAPI()

class DigitalHumanService:
    def __init__(self):
        self.stt = RealtimeSTT()
        self.agent = DigitalHumanAgent()
        self.tts = RealtimeTTS()
        self.lipsync = LivePortraitEngine()
        self.webrtc = WebRTCServer()
    
    async def process_audio(self, audio_chunk: bytes):
        # 1. STT
        text = await self.stt.transcribe_stream(audio_chunk)
        
        # 2. LLM对话
        response_text = ""
        async for chunk in self.agent.chat_stream(text):
            response_text += chunk
        
        # 3. TTS
        audio_chunks = []
        async for audio in self.tts.synthesize_stream(response_text):
            audio_chunks.append(audio)
        
        # 4. 口型同步
        video_frames = []
        for audio in audio_chunks:
            frame = await self.lipsync.generate_frame(audio)
            video_frames.append(frame)
        
        return video_frames, audio_chunks

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    service = DigitalHumanService()
    
    while True:
        audio_data = await websocket.receive_bytes()
        video, audio = await service.process_audio(audio_data)
        
        await websocket.send_json({
            "video": video,
            "audio": audio
        })
```

## 7.2 异步任务队列

```python
from celery import Celery

celery_app = Celery('digital_human', broker='redis://localhost:6379')

@celery_app.task
async def generate_video_task(text: str, avatar_id: str):
    tts = RealtimeTTS()
    lipsync = LivePortraitEngine()
    
    # TTS
    audio_path = await tts.synthesize(text)
    
    # 口型同步
    video_path = await lipsync.generate_video(avatar_id, audio_path)
    
    return video_path
```

## 7.3 状态机管理

```python
from enum import Enum

class ConversationState(Enum):
    IDLE = "idle"
    LISTENING = "listening"
    THINKING = "thinking"
    SPEAKING = "speaking"

class StateMachine:
    def __init__(self):
        self.state = ConversationState.IDLE
    
    async def transition(self, event: str):
        if self.state == ConversationState.IDLE and event == "audio_start":
            self.state = ConversationState.LISTENING
        elif self.state == ConversationState.LISTENING and event == "audio_end":
            self.state = ConversationState.THINKING
        elif self.state == ConversationState.THINKING and event == "llm_done":
            self.state = ConversationState.SPEAKING
        elif self.state == ConversationState.SPEAKING and event == "tts_done":
            self.state = ConversationState.IDLE
```

## 7.4 错误恢复机制

```python
class ErrorHandler:
    async def with_retry(self, func, max_retries=3):
        for i in range(max_retries):
            try:
                return await func()
            except Exception as e:
                if i == max_retries - 1:
                    # 降级策略
                    return await self.fallback()
                await asyncio.sleep(2 ** i)
    
    async def fallback(self):
        return {"text": "抱歉,我遇到了一些问题,请稍后再试"}
```

## 7.5 本章小结
- 微服务架构实现模块解耦
- Celery处理离线任务
- 状态机管理对话流程
- 错误重试保证系统稳定性
