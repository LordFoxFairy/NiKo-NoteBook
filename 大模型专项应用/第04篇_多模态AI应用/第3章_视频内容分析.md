# 第3章 视频内容分析

> 掌握视频处理与智能分析技术

## 3.1 FFmpeg视频处理基础

### 3.1.1 视频帧提取

```python
import ffmpeg
import os
from pathlib import Path

class VideoProcessor:
    """视频处理器"""
    
    @staticmethod
    def extract_frames(
        video_path: str,
        output_dir: str,
        fps: float = 1.0
    ) -> list[str]:
        """
        提取视频帧
        
        Args:
            video_path: 视频路径
            output_dir: 输出目录
            fps: 提取帧率(每秒帧数)
            
        Returns:
            帧图片路径列表
        """
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        output_pattern = os.path.join(output_dir, "frame_%04d.jpg")
        
        (
            ffmpeg
            .input(video_path)
            .filter('fps', fps=fps)
            .output(output_pattern, format='image2', vcodec='mjpeg')
            .overwrite_output()
            .run(quiet=True)
        )
        
        frames = sorted(Path(output_dir).glob("frame_*.jpg"))
        return [str(f) for f in frames]
    
    @staticmethod
    def get_video_info(video_path: str) -> dict:
        """获取视频信息"""
        probe = ffmpeg.probe(video_path)
        video_info = next(s for s in probe['streams'] if s['codec_type'] == 'video')
        
        return {
            'duration': float(probe['format']['duration']),
            'width': int(video_info['width']),
            'height': int(video_info['height']),
            'fps': eval(video_info['r_frame_rate']),
            'codec': video_info['codec_name']
        }

# 使用示例
processor = VideoProcessor()

# 获取视频信息
info = processor.get_video_info("video.mp4")
print(f"时长: {info['duration']}秒, 分辨率: {info['width']}x{info['height']}")

# 提取关键帧(每秒1帧)
frames = processor.extract_frames("video.mp4", "frames/", fps=1.0)
print(f"提取了{len(frames)}帧")
```

## 3.2 视频内容理解

### 3.2.1 视频摘要生成

```python
from typing import List
import json

class VideoAnalyzer:
    """视频分析器"""
    
    def __init__(self, vision_analyzer):
        self.vision_analyzer = vision_analyzer
        self.processor = VideoProcessor()
    
    def analyze_video(
        self,
        video_path: str,
        sample_fps: float = 0.5
    ) -> dict:
        """
        分析视频内容
        
        Args:
            video_path: 视频路径
            sample_fps: 采样帧率
            
        Returns:
            分析结果
        """
        # 提取关键帧
        frames = self.processor.extract_frames(
            video_path,
            "temp_frames",
            fps=sample_fps
        )
        
        # 分析每帧
        frame_descriptions = []
        for i, frame_path in enumerate(frames):
            desc = self.vision_analyzer.analyze_image(
                frame_path,
                f"简要描述第{i+1}帧的主要内容(20字以内)"
            )
            frame_descriptions.append({
                "frame_index": i,
                "timestamp": i / sample_fps,
                "description": desc
            })
        
        # 生成整体摘要
        all_descriptions = "\n".join([
            f"{d['timestamp']:.1f}s: {d['description']}"
            for d in frame_descriptions
        ])
        
        summary_prompt = f"""
        基于以下视频帧描述,生成100字以内的视频摘要:
        
        {all_descriptions}
        """
        
        summary = self.vision_analyzer.analyze_image(
            frames[0],  # 使用第一帧作为参考
            summary_prompt
        )
        
        return {
            "video_path": video_path,
            "duration": len(frames) / sample_fps,
            "frame_count": len(frames),
            "frame_descriptions": frame_descriptions,
            "summary": summary
        }

# 使用示例
from openai import OpenAI

vision_model = GPT4VisionAnalyzer(api_key="your-key")
video_analyzer = VideoAnalyzer(vision_model)

result = video_analyzer.analyze_video("presentation.mp4", sample_fps=0.5)
print(f"视频摘要: {result['summary']}")
```

## 3.3 实时视频流分析

```python
import cv2
from queue import Queue
from threading import Thread

class RealtimeVideoAnalyzer:
    """实时视频流分析器"""
    
    def __init__(self, vision_analyzer, analysis_interval: int = 30):
        self.vision_analyzer = vision_analyzer
        self.analysis_interval = analysis_interval  # 每N帧分析一次
        self.frame_queue = Queue(maxsize=10)
        self.running = False
    
    def start(self, video_source: str = 0):
        """
        启动实时分析
        
        Args:
            video_source: 视频源(0=摄像头, 或视频文件路径)
        """
        self.running = True
        
        # 启动帧捕获线程
        capture_thread = Thread(target=self._capture_frames, args=(video_source,))
        capture_thread.start()
        
        # 启动分析线程
        analysis_thread = Thread(target=self._analyze_frames)
        analysis_thread.start()
    
    def _capture_frames(self, video_source):
        """捕获视频帧"""
        cap = cv2.VideoCapture(video_source)
        frame_count = 0
        
        while self.running:
            ret, frame = cap.read()
            if not ret:
                break
            
            frame_count += 1
            if frame_count % self.analysis_interval == 0:
                if not self.frame_queue.full():
                    self.frame_queue.put(frame)
        
        cap.release()
    
    def _analyze_frames(self):
        """分析帧"""
        while self.running:
            if not self.frame_queue.empty():
                frame = self.frame_queue.get()
                
                # 保存临时图片
                temp_path = "temp_frame.jpg"
                cv2.imwrite(temp_path, frame)
                
                # 分析
                result = self.vision_analyzer.analyze_image(
                    temp_path,
                    "检测画面中是否有异常情况"
                )
                
                print(f"分析结果: {result}")
    
    def stop(self):
        """停止分析"""
        self.running = False

# 使用示例
realtime_analyzer = RealtimeVideoAnalyzer(vision_model, analysis_interval=30)
realtime_analyzer.start(video_source="rtsp://camera_url")

# 运行一段时间后停止
import time
time.sleep(60)
realtime_analyzer.stop()
```

## 本章小结

- FFmpeg是视频处理的瑞士军刀
- 视频分析需要合理的帧采样策略
- 实时分析需要平衡延迟与准确率

---

**下一章**: [第4章 语音分析与识别](./第4章_语音分析与识别.md)
