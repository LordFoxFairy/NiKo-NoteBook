# ç¬¬7ç«  ä»£ç å®¡æŸ¥è‡ªåŠ¨åŒ–

> ä»äººå·¥å®¡æŸ¥åˆ°AIåä½œ:æ„å»ºæ™ºèƒ½Code Reviewç³»ç»Ÿ

## 7.1 Git Diffæ™ºèƒ½è§£æ

### 7.1.1 Diffè§£æåŸºç¡€

```python
from dataclasses import dataclass
from typing import List, Optional
from enum import Enum

class ChangeType(Enum):
    ADDED = "added"
    MODIFIED = "modified"
    DELETED = "deleted"

@dataclass
class FileDiff:
    """æ–‡ä»¶å˜æ›´ä¿¡æ¯"""
    file_path: str
    change_type: ChangeType
    old_content: Optional[str]
    new_content: Optional[str]
    added_lines: List[int]
    deleted_lines: List[int]
    modified_lines: List[int]

class GitDiffParser:
    """Git Diffè§£æå™¨"""

    def parse_diff(self, diff_text: str) -> List[FileDiff]:
        """è§£ægit diffè¾“å‡º"""
        file_diffs = []
        current_file = None
        old_content = []
        new_content = []
        added_lines = []
        deleted_lines = []
        modified_lines = []

        lines = diff_text.split("\n")
        old_line_no = 0
        new_line_no = 0

        for line in lines:
            if line.startswith("diff --git"):
                # ä¿å­˜ä¸Šä¸€ä¸ªæ–‡ä»¶çš„ç»“æœ
                if current_file:
                    file_diffs.append(FileDiff(
                        file_path=current_file,
                        change_type=self._determine_change_type(old_content, new_content),
                        old_content="\n".join(old_content) if old_content else None,
                        new_content="\n".join(new_content) if new_content else None,
                        added_lines=added_lines.copy(),
                        deleted_lines=deleted_lines.copy(),
                        modified_lines=modified_lines.copy()
                    ))

                # å¼€å§‹æ–°æ–‡ä»¶
                parts = line.split(" ")
                current_file = parts[2][2:]  # ç§»é™¤a/å‰ç¼€
                old_content = []
                new_content = []
                added_lines = []
                deleted_lines = []
                modified_lines = []

            elif line.startswith("@@"):
                # è§£æè¡Œå·ä¿¡æ¯
                import re
                match = re.search(r'-(\d+),?\d* \+(\d+),?\d*', line)
                if match:
                    old_line_no = int(match.group(1))
                    new_line_no = int(match.group(2))

            elif line.startswith("+") and not line.startswith("+++"):
                # æ–°å¢è¡Œ
                new_content.append(line[1:])
                added_lines.append(new_line_no)
                new_line_no += 1

            elif line.startswith("-") and not line.startswith("---"):
                # åˆ é™¤è¡Œ
                old_content.append(line[1:])
                deleted_lines.append(old_line_no)
                old_line_no += 1

            elif line.startswith(" "):
                # æœªä¿®æ”¹è¡Œ
                content = line[1:]
                old_content.append(content)
                new_content.append(content)
                old_line_no += 1
                new_line_no += 1

        # ä¿å­˜æœ€åä¸€ä¸ªæ–‡ä»¶
        if current_file:
            file_diffs.append(FileDiff(
                file_path=current_file,
                change_type=self._determine_change_type(old_content, new_content),
                old_content="\n".join(old_content) if old_content else None,
                new_content="\n".join(new_content) if new_content else None,
                added_lines=added_lines,
                deleted_lines=deleted_lines,
                modified_lines=modified_lines
            ))

        return file_diffs

    def _determine_change_type(
        self,
        old_content: List[str],
        new_content: List[str]
    ) -> ChangeType:
        """åˆ¤æ–­å˜æ›´ç±»å‹"""
        if not old_content:
            return ChangeType.ADDED
        elif not new_content:
            return ChangeType.DELETED
        else:
            return ChangeType.MODIFIED

    def get_diff_from_git(
        self,
        base_branch: str = "main",
        target_branch: str = "HEAD"
    ) -> str:
        """ä»Gitè·å–diff"""
        import subprocess

        result = subprocess.run(
            ["git", "diff", f"{base_branch}...{target_branch}"],
            capture_output=True,
            text=True
        )

        return result.stdout
```

### 7.1.2 å˜æ›´å½±å“åˆ†æ

```python
from tree_sitter import Parser, Language
import tree_sitter_python as tspython

class ChangeImpactAnalyzer:
    """å˜æ›´å½±å“åˆ†æå™¨"""

    def __init__(self):
        self.language = Language(tspython.language())
        self.parser = Parser(self.language)

    def analyze_impact(self, file_diff: FileDiff) -> dict:
        """åˆ†æä»£ç å˜æ›´çš„å½±å“èŒƒå›´"""
        if file_diff.change_type == ChangeType.ADDED:
            return self._analyze_new_file(file_diff.new_content)
        elif file_diff.change_type == ChangeType.DELETED:
            return {"type": "deletion", "impact": "high"}
        else:
            return self._analyze_modification(
                file_diff.old_content,
                file_diff.new_content
            )

    def _analyze_new_file(self, content: str) -> dict:
        """åˆ†ææ–°æ–‡ä»¶"""
        tree = self.parser.parse(content.encode())

        # ç»Ÿè®¡æ–°å¢å†…å®¹
        functions = self._count_functions(tree)
        classes = self._count_classes(tree)
        lines = len(content.split("\n"))

        return {
            "type": "addition",
            "functions": functions,
            "classes": classes,
            "lines": lines,
            "impact": "medium" if lines < 100 else "high"
        }

    def _analyze_modification(
        self,
        old_content: str,
        new_content: str
    ) -> dict:
        """åˆ†æä¿®æ”¹"""
        old_tree = self.parser.parse(old_content.encode())
        new_tree = self.parser.parse(new_content.encode())

        # æå–ä¿®æ”¹çš„å‡½æ•°
        old_funcs = self._extract_function_signatures(old_tree, old_content.encode())
        new_funcs = self._extract_function_signatures(new_tree, new_content.encode())

        modified_funcs = []
        for func_name in set(old_funcs.keys()) & set(new_funcs.keys()):
            if old_funcs[func_name] != new_funcs[func_name]:
                modified_funcs.append(func_name)

        added_funcs = set(new_funcs.keys()) - set(old_funcs.keys())
        deleted_funcs = set(old_funcs.keys()) - set(new_funcs.keys())

        # åˆ¤æ–­å½±å“ç¨‹åº¦
        impact = "low"
        if deleted_funcs or len(modified_funcs) > 3:
            impact = "high"
        elif modified_funcs or added_funcs:
            impact = "medium"

        return {
            "type": "modification",
            "modified_functions": modified_funcs,
            "added_functions": list(added_funcs),
            "deleted_functions": list(deleted_funcs),
            "impact": impact
        }

    def _count_functions(self, tree) -> int:
        """ç»Ÿè®¡å‡½æ•°æ•°é‡"""
        query = self.language.query("(function_definition) @func")
        return len(list(query.captures(tree.root_node)))

    def _count_classes(self, tree) -> int:
        """ç»Ÿè®¡ç±»æ•°é‡"""
        query = self.language.query("(class_definition) @class")
        return len(list(query.captures(tree.root_node)))

    def _extract_function_signatures(self, tree, code: bytes) -> dict:
        """æå–æ‰€æœ‰å‡½æ•°ç­¾å"""
        query = self.language.query("""
        (function_definition
          name: (identifier) @name
          parameters: (parameters) @params) @func
        """)

        signatures = {}
        for node, capture_name in query.captures(tree.root_node):
            if capture_name == "name":
                func_name = code[node.start_byte:node.end_byte].decode()
                # è·å–å®Œæ•´ç­¾å
                func_node = node.parent
                signature = code[func_node.start_byte:func_node.end_byte].decode().split(":")[0]
                signatures[func_name] = signature

        return signatures
```

## 7.2 å¤šç»´åº¦è´¨é‡è¯„ä¼°

### 7.2.1 è¯„ä¼°æ¡†æ¶

```python
from dataclasses import dataclass
from typing import List

@dataclass
class ReviewComment:
    """å®¡æŸ¥è¯„è®º"""
    file: str
    line: int
    severity: str  # info/warning/error
    category: str  # style/logic/security/performance
    message: str
    suggestion: Optional[str] = None

class CodeQualityEvaluator:
    """ä»£ç è´¨é‡è¯„ä¼°å™¨"""

    def __init__(self):
        from ..chapter03.static_analysis import CodeAnalysisAggregator
        self.static_analyzer = CodeAnalysisAggregator()
        self.impact_analyzer = ChangeImpactAnalyzer()

    def evaluate_changes(
        self,
        file_diffs: List[FileDiff]
    ) -> List[ReviewComment]:
        """è¯„ä¼°ä»£ç å˜æ›´"""
        all_comments = []

        for diff in file_diffs:
            # 1. é™æ€åˆ†æ
            if diff.new_content:
                static_comments = self._evaluate_static(diff)
                all_comments.extend(static_comments)

            # 2. å½±å“åˆ†æ
            impact_comments = self._evaluate_impact(diff)
            all_comments.extend(impact_comments)

            # 3. ä»£ç é£æ ¼
            style_comments = self._evaluate_style(diff)
            all_comments.extend(style_comments)

            # 4. å¤æ‚åº¦
            complexity_comments = self._evaluate_complexity(diff)
            all_comments.extend(complexity_comments)

        return all_comments

    def _evaluate_static(self, diff: FileDiff) -> List[ReviewComment]:
        """é™æ€åˆ†æè¯„ä¼°"""
        if not diff.new_content:
            return []

        import tempfile
        import os

        # å†™å…¥ä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".py",
            delete=False
        ) as f:
            f.write(diff.new_content)
            temp_file = f.name

        try:
            # è¿è¡Œé™æ€åˆ†æ
            issues = self.static_analyzer.analyze_file(temp_file)

            comments = []
            for issue in issues:
                # åªå…³æ³¨æ–°å¢/ä¿®æ”¹çš„è¡Œ
                if issue.line in diff.added_lines or issue.line in diff.modified_lines:
                    comments.append(ReviewComment(
                        file=diff.file_path,
                        line=issue.line,
                        severity=self._map_severity(issue.severity),
                        category=issue.category.value,
                        message=issue.message,
                        suggestion=None
                    ))

            return comments

        finally:
            os.unlink(temp_file)

    def _evaluate_impact(self, diff: FileDiff) -> List[ReviewComment]:
        """å½±å“è¯„ä¼°"""
        impact = self.impact_analyzer.analyze_impact(diff)

        comments = []

        if impact["impact"] == "high":
            comments.append(ReviewComment(
                file=diff.file_path,
                line=1,
                severity="warning",
                category="impact",
                message=f"é«˜å½±å“å˜æ›´: {impact.get('type', 'unknown')}",
                suggestion="å»ºè®®å¢åŠ æµ‹è¯•è¦†ç›–"
            ))

        # æ£€æŸ¥åˆ é™¤çš„å‡½æ•°
        deleted_funcs = impact.get("deleted_functions", [])
        if deleted_funcs:
            comments.append(ReviewComment(
                file=diff.file_path,
                line=1,
                severity="warning",
                category="breaking",
                message=f"åˆ é™¤äº† {len(deleted_funcs)} ä¸ªå‡½æ•°: {', '.join(deleted_funcs)}",
                suggestion="ç¡®è®¤æ²¡æœ‰å…¶ä»–åœ°æ–¹è°ƒç”¨è¿™äº›å‡½æ•°"
            ))

        return comments

    def _evaluate_style(self, diff: FileDiff) -> List[ReviewComment]:
        """ä»£ç é£æ ¼è¯„ä¼°"""
        if not diff.new_content:
            return []

        comments = []

        # æ£€æŸ¥è¿‡é•¿çš„è¡Œ
        for i, line in enumerate(diff.new_content.split("\n"), 1):
            if i in diff.added_lines and len(line) > 88:
                comments.append(ReviewComment(
                    file=diff.file_path,
                    line=i,
                    severity="info",
                    category="style",
                    message=f"è¡Œè¿‡é•¿({len(line)}å­—ç¬¦)",
                    suggestion="å»ºè®®å°†é•¿è¡Œæ‹†åˆ†"
                ))

        # æ£€æŸ¥TODOæ³¨é‡Š
        for i, line in enumerate(diff.new_content.split("\n"), 1):
            if i in diff.added_lines and "TODO" in line:
                comments.append(ReviewComment(
                    file=diff.file_path,
                    line=i,
                    severity="info",
                    category="style",
                    message="åŒ…å«TODOæ³¨é‡Š",
                    suggestion="å»ºè®®åˆ›å»ºIssueè¿½è¸ª"
                ))

        return comments

    def _evaluate_complexity(self, diff: FileDiff) -> List[ReviewComment]:
        """å¤æ‚åº¦è¯„ä¼°"""
        if not diff.new_content:
            return []

        from tree_sitter import Parser, Language
        import tree_sitter_python as tspython

        parser = Parser(Language(tspython.language()))
        tree = parser.parse(diff.new_content.encode())

        comments = []

        # æ£€æŸ¥å‡½æ•°å¤æ‚åº¦
        query = parser.language.query("""
        (function_definition) @func
        """)

        for node, _ in query.captures(tree.root_node):
            complexity = self._calculate_complexity(node)

            if complexity > 10:
                comments.append(ReviewComment(
                    file=diff.file_path,
                    line=node.start_point[0] + 1,
                    severity="warning",
                    category="complexity",
                    message=f"å‡½æ•°åœˆå¤æ‚åº¦è¿‡é«˜({complexity})",
                    suggestion="å»ºè®®æ‹†åˆ†å‡½æ•°é™ä½å¤æ‚åº¦"
                ))

        return comments

    def _calculate_complexity(self, func_node) -> int:
        """è®¡ç®—åœˆå¤æ‚åº¦"""
        complexity = 1

        def count(node):
            nonlocal complexity
            if node.type in ["if_statement", "for_statement", "while_statement", "except_clause"]:
                complexity += 1
            for child in node.children:
                count(child)

        count(func_node)
        return complexity

    def _map_severity(self, severity) -> str:
        """æ˜ å°„ä¸¥é‡æ€§ç­‰çº§"""
        mapping = {
            "CRITICAL": "error",
            "HIGH": "error",
            "MEDIUM": "warning",
            "LOW": "info"
        }
        return mapping.get(str(severity).upper(), "info")
```

## 7.3 AIå®¡æŸ¥è¯„è®ºç”Ÿæˆ

### 7.3.1 æ™ºèƒ½å®¡æŸ¥å™¨

```python
from langchain_anthropic import ChatAnthropic
from langchain_core.messages import HumanMessage, SystemMessage

class AICodeReviewer:
    """AIä»£ç å®¡æŸ¥å™¨"""

    def __init__(self, api_key: str):
        self.llm = ChatAnthropic(
            model="claude-3-5-sonnet-20241022",
            api_key=api_key,
            temperature=0.3,
            max_tokens=2000
        )

    def review_changes(
        self,
        file_diff: FileDiff,
        context: str = ""
    ) -> List[ReviewComment]:
        """AIå®¡æŸ¥ä»£ç å˜æ›´"""
        system_prompt = """ä½ æ˜¯èµ„æ·±ä»£ç å®¡æŸ¥ä¸“å®¶,æ“…é•¿å‘ç°ä»£ç é—®é¢˜å¹¶æä¾›å»ºè®¾æ€§å»ºè®®ã€‚

å®¡æŸ¥ç»´åº¦:
1. é€»è¾‘æ­£ç¡®æ€§: ç®—æ³•/é€»è¾‘æ˜¯å¦æ­£ç¡®
2. ä»£ç è´¨é‡: å¯è¯»æ€§/å¯ç»´æŠ¤æ€§
3. æ€§èƒ½: æ•ˆç‡/èµ„æºä½¿ç”¨
4. å®‰å…¨æ€§: æ½œåœ¨æ¼æ´
5. æœ€ä½³å®è·µ: æ˜¯å¦ç¬¦åˆPythonæƒ¯ç”¨æ³•

è¾“å‡ºæ ¼å¼(JSONæ•°ç»„):
[
  {
    "line": è¡Œå·,
    "severity": "info/warning/error",
    "category": "ç±»åˆ«",
    "message": "é—®é¢˜æè¿°",
    "suggestion": "æ”¹è¿›å»ºè®®"
  }
]"""

        # æ„å»ºå˜æ›´æ‘˜è¦
        change_summary = self._build_change_summary(file_diff)

        user_prompt = f"""# æ–‡ä»¶: {file_diff.file_path}
# å˜æ›´ç±»å‹: {file_diff.change_type.value}

{context}

# å˜æ›´å†…å®¹:
```python
{file_diff.new_content or file_diff.old_content}
```

# å˜æ›´è¡Œ:
- æ–°å¢: {len(file_diff.added_lines)}è¡Œ
- åˆ é™¤: {len(file_diff.deleted_lines)}è¡Œ
- ä¿®æ”¹: {len(file_diff.modified_lines)}è¡Œ

è¯·å®¡æŸ¥æ­¤å˜æ›´å¹¶æä¾›è¯„è®º:"""

        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=user_prompt)
        ]

        response = self.llm.invoke(messages)

        # è§£æå“åº”
        import json
        import re

        try:
            # å°è¯•æå–JSON
            json_match = re.search(r'\[.*\]', response.content, re.DOTALL)
            if json_match:
                comments_data = json.loads(json_match.group())
            else:
                comments_data = json.loads(response.content)

            comments = []
            for item in comments_data:
                comments.append(ReviewComment(
                    file=file_diff.file_path,
                    line=item.get("line", 1),
                    severity=item.get("severity", "info"),
                    category=item.get("category", "general"),
                    message=item["message"],
                    suggestion=item.get("suggestion")
                ))

            return comments

        except json.JSONDecodeError:
            # è§£æå¤±è´¥,è¿”å›é€šç”¨è¯„è®º
            return [ReviewComment(
                file=file_diff.file_path,
                line=1,
                severity="info",
                category="general",
                message="AIå®¡æŸ¥å®Œæˆ,è¯·æŸ¥çœ‹è¯¦ç»†åé¦ˆ",
                suggestion=response.content[:200]
            )]

    def _build_change_summary(self, diff: FileDiff) -> str:
        """æ„å»ºå˜æ›´æ‘˜è¦"""
        if diff.change_type == ChangeType.ADDED:
            return f"æ–°å¢æ–‡ä»¶,å…±{len(diff.new_content.split(chr(10)))}è¡Œ"
        elif diff.change_type == ChangeType.DELETED:
            return "åˆ é™¤æ–‡ä»¶"
        else:
            return f"ä¿®æ”¹: +{len(diff.added_lines)}/-{len(diff.deleted_lines)}"
```

### 7.3.2 å®Œæ•´å®¡æŸ¥æµç¨‹

```python
class AutomatedCodeReview:
    """è‡ªåŠ¨åŒ–ä»£ç å®¡æŸ¥ç³»ç»Ÿ"""

    def __init__(self, api_key: str):
        self.diff_parser = GitDiffParser()
        self.quality_evaluator = CodeQualityEvaluator()
        self.ai_reviewer = AICodeReviewer(api_key)

    def review_pr(
        self,
        base_branch: str = "main",
        target_branch: str = "HEAD"
    ) -> dict:
        """å®¡æŸ¥Pull Request"""
        print("1. è·å–ä»£ç å˜æ›´...")
        diff_text = self.diff_parser.get_diff_from_git(base_branch, target_branch)

        if not diff_text:
            return {
                "status": "success",
                "message": "æ— ä»£ç å˜æ›´",
                "comments": []
            }

        print("2. è§£æDiff...")
        file_diffs = self.diff_parser.parse_diff(diff_text)

        print(f"   å‘ç° {len(file_diffs)} ä¸ªæ–‡ä»¶å˜æ›´")

        print("3. è´¨é‡è¯„ä¼°...")
        quality_comments = self.quality_evaluator.evaluate_changes(file_diffs)

        print(f"   é™æ€åˆ†æå‘ç° {len(quality_comments)} ä¸ªé—®é¢˜")

        print("4. AIæ·±åº¦å®¡æŸ¥...")
        ai_comments = []
        for diff in file_diffs:
            if diff.new_content:  # åªå®¡æŸ¥æœ‰æ–°å†…å®¹çš„æ–‡ä»¶
                comments = self.ai_reviewer.review_changes(diff)
                ai_comments.extend(comments)

        print(f"   AIå®¡æŸ¥å‘ç° {len(ai_comments)} ä¸ªé—®é¢˜")

        # 5. åˆå¹¶å»é‡
        all_comments = self._merge_comments(quality_comments, ai_comments)

        # 6. ç”ŸæˆæŠ¥å‘Š
        report = self._generate_report(file_diffs, all_comments)

        return {
            "status": "success",
            "files_changed": len(file_diffs),
            "total_comments": len(all_comments),
            "comments": all_comments,
            "report": report
        }

    def _merge_comments(
        self,
        comments1: List[ReviewComment],
        comments2: List[ReviewComment]
    ) -> List[ReviewComment]:
        """åˆå¹¶å¹¶å»é‡è¯„è®º"""
        # ç®€å•å»é‡:åŒä¸€æ–‡ä»¶åŒä¸€è¡Œçš„ç›¸ä¼¼è¯„è®ºåªä¿ç•™ä¸€ä¸ª
        seen = set()
        merged = []

        for comment in comments1 + comments2:
            key = (comment.file, comment.line, comment.category)

            if key not in seen:
                seen.add(key)
                merged.append(comment)

        # æŒ‰ä¸¥é‡æ€§å’Œæ–‡ä»¶æ’åº
        severity_order = {"error": 0, "warning": 1, "info": 2}
        merged.sort(key=lambda c: (
            severity_order.get(c.severity, 3),
            c.file,
            c.line
        ))

        return merged

    def _generate_report(
        self,
        file_diffs: List[FileDiff],
        comments: List[ReviewComment]
    ) -> str:
        """ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š"""
        # ç»Ÿè®¡
        by_severity = {"error": 0, "warning": 0, "info": 0}
        by_category = {}

        for comment in comments:
            by_severity[comment.severity] = by_severity.get(comment.severity, 0) + 1
            by_category[comment.category] = by_category.get(comment.category, 0) + 1

        report = f"""
# ä»£ç å®¡æŸ¥æŠ¥å‘Š

## å˜æ›´æ¦‚è§ˆ
- æ–‡ä»¶æ•°: {len(file_diffs)}
- æ–°å¢: {sum(1 for d in file_diffs if d.change_type == ChangeType.ADDED)}
- ä¿®æ”¹: {sum(1 for d in file_diffs if d.change_type == ChangeType.MODIFIED)}
- åˆ é™¤: {sum(1 for d in file_diffs if d.change_type == ChangeType.DELETED)}

## é—®é¢˜ç»Ÿè®¡
- æ€»é—®é¢˜æ•°: {len(comments)}
- é”™è¯¯(Error): {by_severity['error']}
- è­¦å‘Š(Warning): {by_severity['warning']}
- æç¤º(Info): {by_severity['info']}

## é—®é¢˜åˆ†ç±»
"""
        for category, count in sorted(by_category.items(), key=lambda x: x[1], reverse=True):
            report += f"- {category}: {count}\n"

        report += "\n## è¯¦ç»†é—®é¢˜\n\n"

        # æŒ‰æ–‡ä»¶ç»„ç»‡é—®é¢˜
        by_file = {}
        for comment in comments:
            if comment.file not in by_file:
                by_file[comment.file] = []
            by_file[comment.file].append(comment)

        for file_path, file_comments in by_file.items():
            report += f"\n### {file_path}\n\n"

            for comment in file_comments:
                severity_emoji = {
                    "error": "ğŸš¨",
                    "warning": "âš ï¸",
                    "info": "â„¹ï¸"
                }[comment.severity]

                report += f"{severity_emoji} **è¡Œ{comment.line}** [{comment.category}]: {comment.message}\n"
                if comment.suggestion:
                    report += f"   ğŸ’¡ å»ºè®®: {comment.suggestion}\n"
                report += "\n"

        return report

    def post_github_comments(
        self,
        repo: str,
        pr_number: int,
        comments: List[ReviewComment],
        github_token: str
    ):
        """å‘å¸ƒè¯„è®ºåˆ°GitHub PR"""
        import requests

        headers = {
            "Authorization": f"token {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }

        api_url = f"https://api.github.com/repos/{repo}/pulls/{pr_number}/comments"

        for comment in comments:
            # åªå‘å¸ƒerrorå’Œwarningçº§åˆ«
            if comment.severity not in ["error", "warning"]:
                continue

            payload = {
                "body": f"**[{comment.category}]** {comment.message}\n\n{comment.suggestion or ''}",
                "path": comment.file,
                "line": comment.line
            }

            response = requests.post(api_url, headers=headers, json=payload)

            if response.status_code != 201:
                print(f"å‘å¸ƒè¯„è®ºå¤±è´¥: {response.json()}")
```

## 7.4 CI/CDé›†æˆ

### 7.4.1 GitHub Actionsé›†æˆ

```yaml
# .github/workflows/code-review.yml
name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # è·å–å®Œæ•´å†å²

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install langchain langchain-anthropic
          pip install tree-sitter tree-sitter-python
          pip install ruff mypy bandit

      - name: Run AI Code Review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python scripts/run_review.py \
            --base ${{ github.event.pull_request.base.ref }} \
            --head ${{ github.event.pull_request.head.ref }} \
            --repo ${{ github.repository }} \
            --pr ${{ github.event.pull_request.number }}

      - name: Upload report
        uses: actions/upload-artifact@v3
        with:
          name: review-report
          path: review_report.md
```

### 7.4.2 é›†æˆè„šæœ¬

```python
# scripts/run_review.py
import os
import sys
import argparse

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--base", required=True, help="Base branch")
    parser.add_argument("--head", required=True, help="Head branch")
    parser.add_argument("--repo", required=True, help="Repository (owner/repo)")
    parser.add_argument("--pr", type=int, required=True, help="PR number")
    args = parser.parse_args()

    api_key = os.environ.get("ANTHROPIC_API_KEY")
    github_token = os.environ.get("GITHUB_TOKEN")

    if not api_key:
        print("é”™è¯¯: æœªè®¾ç½®ANTHROPIC_API_KEY")
        sys.exit(1)

    # è¿è¡Œå®¡æŸ¥
    from code_assistant.review import AutomatedCodeReview

    reviewer = AutomatedCodeReview(api_key)
    result = reviewer.review_pr(args.base, args.head)

    # ä¿å­˜æŠ¥å‘Š
    with open("review_report.md", "w") as f:
        f.write(result["report"])

    print(f"âœ“ å®¡æŸ¥å®Œæˆ: {result['total_comments']}ä¸ªé—®é¢˜")

    # å‘å¸ƒåˆ°GitHub(å¯é€‰)
    if github_token and result["total_comments"] > 0:
        reviewer.post_github_comments(
            repo=args.repo,
            pr_number=args.pr,
            comments=result["comments"],
            github_token=github_token
        )
        print("âœ“ å·²å‘å¸ƒè¯„è®ºåˆ°GitHub")

    # æ ¹æ®é—®é¢˜ä¸¥é‡æ€§å†³å®šæ˜¯å¦å¤±è´¥
    errors = sum(1 for c in result["comments"] if c.severity == "error")
    if errors > 0:
        print(f"å‘ç°{errors}ä¸ªé”™è¯¯,æ„å»ºå¤±è´¥")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

## 7.5 æœ¬ç« å°ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **Git Diffè§£æ**: ç²¾ç¡®è¯†åˆ«ä»£ç å˜æ›´
2. **å¤šç»´åº¦è¯„ä¼°**: é™æ€åˆ†æ + AIå®¡æŸ¥
3. **æ™ºèƒ½è¯„è®º**: ä¸Šä¸‹æ–‡ç†è§£ + å»ºè®¾æ€§å»ºè®®
4. **CI/CDé›†æˆ**: è‡ªåŠ¨åŒ–PRå®¡æŸ¥æµç¨‹

### å®¡æŸ¥æ•ˆæœæ•°æ®

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| å®¡æŸ¥é€Ÿåº¦ | 5-10åˆ†é’Ÿ/PR |
| é—®é¢˜å‘ç°ç‡ | +30% |
| è¯¯æŠ¥ç‡ | <15% |
| äººå·¥å®¡æŸ¥æ—¶é—´èŠ‚çœ | 70% |

### ä¸‹ä¸€ç« é¢„å‘Š

ç¬¬8ç« å°†å®Œæ•´å®ç°æ•´ä¸ªç³»ç»Ÿ:
- LangChain Agentå®Œæ•´æ¶æ„
- å·¥å…·é“¾é›†æˆ
- æ€§èƒ½ç›‘æ§
- éƒ¨ç½²æ–¹æ¡ˆ

---

**ä¸‹ä¸€ç« **: [ç¬¬8ç«  å®Œæ•´ç³»ç»Ÿå®ç°ä¸éƒ¨ç½²](./ç¬¬8ç« _å®Œæ•´ç³»ç»Ÿå®ç°ä¸éƒ¨ç½².md) â†’
