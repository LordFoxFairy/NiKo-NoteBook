# 第6章 测试用例自动生成

> 从代码到测试:AI驱动的Pytest测试套件自动化生成

## 6.1 测试场景提取

### 6.1.1 基于AST的函数分析

```python
from dataclasses import dataclass
from typing import List, Optional
from tree_sitter import Parser, Language
import tree_sitter_python as tspython

@dataclass
class FunctionInfo:
    """函数信息"""
    name: str
    parameters: List[dict]  # [{"name": "x", "type": "int", "default": None}]
    return_type: Optional[str]
    docstring: Optional[str]
    complexity: int  # 路径数量
    has_loops: bool
    has_conditions: bool
    has_exceptions: bool
    calls_external: List[str]  # 调用的外部函数

class TestScenarioExtractor:
    """测试场景提取器"""

    def __init__(self):
        self.language = Language(tspython.language())
        self.parser = Parser(self.language)

    def extract_function_info(self, code: bytes, func_name: str) -> Optional[FunctionInfo]:
        """提取函数完整信息"""
        tree = self.parser.parse(code)

        # 查找目标函数
        query = self.language.query(f"""
        (function_definition
          name: (identifier) @func_name
          (#eq? @func_name "{func_name}")
          parameters: (parameters) @params
          body: (block) @body) @func
        """)

        captures = dict(query.captures(tree.root_node))
        if "func" not in captures:
            return None

        func_node = captures["func"]
        params_node = captures.get("params")
        body_node = captures.get("body")

        # 提取参数
        parameters = self._extract_parameters(params_node, code)

        # 提取返回类型
        return_type = self._extract_return_type(func_node, code)

        # 提取文档字符串
        docstring = self._extract_docstring(body_node, code)

        # 分析复杂度
        complexity = self._calculate_complexity(body_node)

        # 检查特征
        has_loops = self._has_loops(body_node)
        has_conditions = self._has_conditions(body_node)
        has_exceptions = self._has_exceptions(body_node)
        calls_external = self._extract_external_calls(body_node, code)

        return FunctionInfo(
            name=func_name,
            parameters=parameters,
            return_type=return_type,
            docstring=docstring,
            complexity=complexity,
            has_loops=has_loops,
            has_conditions=has_conditions,
            has_exceptions=has_exceptions,
            calls_external=calls_external
        )

    def _extract_parameters(self, params_node, code: bytes) -> List[dict]:
        """提取函数参数信息"""
        if not params_node:
            return []

        parameters = []

        for child in params_node.children:
            if child.type == "identifier":
                param_name = code[child.start_byte:child.end_byte].decode()
                parameters.append({
                    "name": param_name,
                    "type": None,
                    "default": None
                })
            elif child.type == "typed_parameter":
                # 带类型注解的参数
                name_node = child.child_by_field_name("name")
                type_node = child.child_by_field_name("type")

                param_name = code[name_node.start_byte:name_node.end_byte].decode()
                param_type = code[type_node.start_byte:type_node.end_byte].decode() if type_node else None

                parameters.append({
                    "name": param_name,
                    "type": param_type,
                    "default": None
                })
            elif child.type == "default_parameter":
                # 带默认值的参数
                name_node = child.child_by_field_name("name")
                value_node = child.child_by_field_name("value")

                param_name = code[name_node.start_byte:name_node.end_byte].decode()
                default_value = code[value_node.start_byte:value_node.end_byte].decode() if value_node else None

                parameters.append({
                    "name": param_name,
                    "type": None,
                    "default": default_value
                })

        return parameters

    def _extract_return_type(self, func_node, code: bytes) -> Optional[str]:
        """提取返回类型"""
        return_type_node = func_node.child_by_field_name("return_type")
        if return_type_node:
            return code[return_type_node.start_byte:return_type_node.end_byte].decode()
        return None

    def _extract_docstring(self, body_node, code: bytes) -> Optional[str]:
        """提取文档字符串"""
        if not body_node or not body_node.children:
            return None

        first_statement = body_node.children[0]
        if first_statement.type == "expression_statement":
            string_node = first_statement.children[0]
            if string_node.type == "string":
                docstring = code[string_node.start_byte:string_node.end_byte].decode()
                return docstring.strip('"\'')

        return None

    def _calculate_complexity(self, body_node) -> int:
        """计算圈复杂度"""
        if not body_node:
            return 1

        complexity = 1  # 基础路径

        def count_decision_points(node):
            nonlocal complexity
            if node.type in ["if_statement", "for_statement", "while_statement", "except_clause"]:
                complexity += 1

            for child in node.children:
                count_decision_points(child)

        count_decision_points(body_node)
        return complexity

    def _has_loops(self, body_node) -> bool:
        """检查是否包含循环"""
        if not body_node:
            return False

        def check(node):
            if node.type in ["for_statement", "while_statement"]:
                return True
            return any(check(child) for child in node.children)

        return check(body_node)

    def _has_conditions(self, body_node) -> bool:
        """检查是否包含条件语句"""
        if not body_node:
            return False

        def check(node):
            if node.type == "if_statement":
                return True
            return any(check(child) for child in node.children)

        return check(body_node)

    def _has_exceptions(self, body_node) -> bool:
        """检查是否包含异常处理"""
        if not body_node:
            return False

        def check(node):
            if node.type in ["try_statement", "raise_statement"]:
                return True
            return any(check(child) for child in node.children)

        return check(body_node)

    def _extract_external_calls(self, body_node, code: bytes) -> List[str]:
        """提取外部函数调用"""
        if not body_node:
            return []

        calls = []

        def extract_calls(node):
            if node.type == "call":
                func_node = node.child_by_field_name("function")
                if func_node:
                    func_name = code[func_node.start_byte:func_node.end_byte].decode()
                    if func_name not in calls:
                        calls.append(func_name)

            for child in node.children:
                extract_calls(child)

        extract_calls(body_node)
        return calls
```

## 6.2 测试代码生成

### 6.2.1 AI驱动的测试生成

```python
from langchain_anthropic import ChatAnthropic
from langchain_core.messages import HumanMessage, SystemMessage

class TestGenerator:
    """测试用例生成器"""

    def __init__(self, api_key: str):
        self.llm = ChatAnthropic(
            model="claude-3-5-sonnet-20241022",
            api_key=api_key,
            temperature=0.3,
            max_tokens=3000
        )
        self.extractor = TestScenarioExtractor()

    def generate_tests(
        self,
        code: str,
        func_name: str
    ) -> str:
        """为指定函数生成测试用例"""
        # 1. 提取函数信息
        func_info = self.extractor.extract_function_info(
            code.encode(),
            func_name
        )

        if not func_info:
            return f"# 未找到函数: {func_name}"

        # 2. 构建提示
        system_prompt = """你是Python测试专家,擅长编写Pytest测试用例。

要求:
1. 使用pytest框架
2. 包含正常情况、边界情况、异常情况
3. 使用参数化测试(@pytest.mark.parametrize)
4. 添加清晰的测试说明
5. 使用合适的断言
6. 如需mock,使用pytest-mock

测试原则:
- 每个测试只验证一个行为
- 测试名称清晰描述测试内容
- 使用AAA模式(Arrange-Act-Assert)"""

        user_prompt = self._build_test_prompt(func_info, code)

        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=user_prompt)
        ]

        response = self.llm.invoke(messages)
        return response.content

    def _build_test_prompt(self, func_info: FunctionInfo, full_code: str) -> str:
        """构建测试生成提示"""
        # 参数信息
        params_desc = "\n".join([
            f"- {p['name']}: {p['type'] or '未标注'}"
            + (f" (默认: {p['default']})" if p['default'] else "")
            for p in func_info.parameters
        ])

        # 函数特征
        features = []
        if func_info.has_loops:
            features.append("包含循环")
        if func_info.has_conditions:
            features.append("包含条件判断")
        if func_info.has_exceptions:
            features.append("包含异常处理")
        if func_info.calls_external:
            features.append(f"调用外部函数: {', '.join(func_info.calls_external)}")

        features_desc = "、".join(features) if features else "简单函数"

        prompt = f"""# 函数信息
名称: {func_info.name}
返回类型: {func_info.return_type or '未标注'}
圈复杂度: {func_info.complexity}
特征: {features_desc}

# 参数列表
{params_desc}

# 文档字符串
{func_info.docstring or '(无)'}

# 函数实现
```python
{full_code}
```

请生成完整的pytest测试用例,包括:
1. 正常情况测试(至少2个)
2. 边界情况测试(空值、零、极值等)
3. 异常情况测试(如果适用)
4. 参数化测试(如果适用)

测试代码:"""

        return prompt

    def generate_test_suite(self, file_path: str) -> dict:
        """为整个文件生成测试套件"""
        with open(file_path, "r") as f:
            code = f.read()

        # 提取所有函数
        tree = self.extractor.parser.parse(code.encode())
        query = self.extractor.language.query("""
        (function_definition
          name: (identifier) @func_name) @func
        """)

        functions = []
        for node, name in query.captures(tree.root_node):
            if name == "func_name":
                func_name = code[node.start_byte:node.end_byte]
                if not func_name.startswith("_"):  # 跳过私有函数
                    functions.append(func_name)

        # 为每个函数生成测试
        test_suite = []
        for func_name in functions:
            print(f"生成测试: {func_name}")
            tests = self.generate_tests(code, func_name)
            test_suite.append({
                "function": func_name,
                "tests": tests
            })

        return {
            "source_file": file_path,
            "test_file": file_path.replace(".py", "_test.py"),
            "functions": test_suite
        }
```

### 6.2.2 测试模板库

```python
class TestTemplateLibrary:
    """测试模板库"""

    @staticmethod
    def generate_basic_test(func_name: str, params: List[dict]) -> str:
        """生成基础测试模板"""
        param_names = [p["name"] for p in params]
        param_str = ", ".join(param_names)

        return f"""
def test_{func_name}_basic():
    \"\"\"测试{func_name}的基本功能\"\"\"
    # Arrange
    {chr(10).join(f"    {p['name']} = ..." for p in params)}

    # Act
    result = {func_name}({param_str})

    # Assert
    assert result is not None
"""

    @staticmethod
    def generate_parametrized_test(
        func_name: str,
        test_cases: List[dict]
    ) -> str:
        """生成参数化测试"""
        # 提取参数名
        param_names = list(test_cases[0].keys())
        param_names.remove("expected")

        param_str = ", ".join(param_names)
        test_values = []

        for case in test_cases:
            values = [str(case[p]) for p in param_names]
            values.append(str(case["expected"]))
            test_values.append(f"    ({', '.join(values)})")

        return f"""
@pytest.mark.parametrize("{param_str}, expected", [
{chr(10).join(test_values)}
])
def test_{func_name}_parametrized({param_str}, expected):
    \"\"\"参数化测试{func_name}\"\"\"
    result = {func_name}({param_str})
    assert result == expected
"""

    @staticmethod
    def generate_exception_test(
        func_name: str,
        exception_type: str,
        params: List[dict]
    ) -> str:
        """生成异常测试"""
        param_names = [p["name"] for p in params]
        param_str = ", ".join(param_names)

        return f"""
def test_{func_name}_raises_{exception_type.lower()}():
    \"\"\"测试{func_name}抛出{exception_type}\"\"\"
    # Arrange
    {chr(10).join(f"    {p['name']} = ..."  for p in params)}

    # Act & Assert
    with pytest.raises({exception_type}):
        {func_name}({param_str})
"""

    @staticmethod
    def generate_mock_test(
        func_name: str,
        mock_target: str
    ) -> str:
        """生成需要mock的测试"""
        return f"""
def test_{func_name}_with_mock(mocker):
    \"\"\"使用mock测试{func_name}\"\"\"
    # Arrange
    mock_{mock_target} = mocker.patch('{mock_target}')
    mock_{mock_target}.return_value = ...

    # Act
    result = {func_name}(...)

    # Assert
    assert result == ...
    mock_{mock_target}.assert_called_once()
"""
```

## 6.3 覆盖率驱动优化

### 6.3.1 覆盖率分析

```python
import subprocess
import json

class CoverageAnalyzer:
    """测试覆盖率分析器"""

    def run_coverage(
        self,
        test_file: str,
        source_file: str
    ) -> dict:
        """运行测试并收集覆盖率"""
        # 运行pytest with coverage
        cmd = [
            "pytest",
            test_file,
            f"--cov={source_file}",
            "--cov-report=json",
            "--cov-report=term"
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True
        )

        # 解析覆盖率报告
        try:
            with open("coverage.json", "r") as f:
                coverage_data = json.load(f)

            return self._parse_coverage(coverage_data)
        except FileNotFoundError:
            return {"error": "覆盖率报告未生成"}

    def _parse_coverage(self, coverage_data: dict) -> dict:
        """解析覆盖率数据"""
        summary = coverage_data.get("totals", {})

        result = {
            "line_coverage": summary.get("percent_covered", 0),
            "lines_covered": summary.get("covered_lines", 0),
            "lines_total": summary.get("num_statements", 0),
            "missing_lines": summary.get("missing_lines", []),
            "excluded_lines": summary.get("excluded_lines", [])
        }

        # 提取未覆盖的行
        files = coverage_data.get("files", {})
        for file_path, file_data in files.items():
            result["uncovered_lines"] = file_data.get("missing_lines", [])

        return result

    def identify_untested_paths(
        self,
        source_file: str,
        coverage_result: dict
    ) -> List[dict]:
        """识别未测试的代码路径"""
        uncovered_lines = coverage_result.get("uncovered_lines", [])

        if not uncovered_lines:
            return []

        with open(source_file, "r") as f:
            code = f.read()

        # 分析未覆盖行的上下文
        untested_paths = []
        for line_no in uncovered_lines:
            context = self._get_line_context(code, line_no)
            untested_paths.append({
                "line": line_no,
                "code": context["code"],
                "type": context["type"],  # condition/loop/exception
                "function": context["function"]
            })

        return untested_paths

    def _get_line_context(self, code: str, line_no: int) -> dict:
        """获取行的上下文信息"""
        lines = code.split("\n")
        if line_no > len(lines):
            return {"code": "", "type": "unknown", "function": None}

        target_line = lines[line_no - 1].strip()

        # 判断类型
        line_type = "statement"
        if "if " in target_line or "elif " in target_line:
            line_type = "condition"
        elif "for " in target_line or "while " in target_line:
            line_type = "loop"
        elif "except " in target_line or "raise " in target_line:
            line_type = "exception"

        # 查找所属函数(向上查找def)
        function = None
        for i in range(line_no - 1, -1, -1):
            if lines[i].strip().startswith("def "):
                import re
                match = re.match(r'def (\w+)', lines[i].strip())
                if match:
                    function = match.group(1)
                break

        return {
            "code": target_line,
            "type": line_type,
            "function": function
        }
```

### 6.3.2 增量测试生成

```python
class IncrementalTestGenerator:
    """增量测试生成器"""

    def __init__(self, api_key: str):
        self.generator = TestGenerator(api_key)
        self.coverage_analyzer = CoverageAnalyzer()

    def improve_coverage(
        self,
        source_file: str,
        test_file: str,
        target_coverage: float = 0.9
    ) -> str:
        """增量生成测试以提高覆盖率"""
        iteration = 0
        max_iterations = 5

        while iteration < max_iterations:
            print(f"\n迭代 {iteration + 1}:")

            # 1. 运行当前测试并获取覆盖率
            coverage = self.coverage_analyzer.run_coverage(test_file, source_file)

            current_coverage = coverage["line_coverage"] / 100
            print(f"  当前覆盖率: {current_coverage:.1%}")

            if current_coverage >= target_coverage:
                print(f"  ✓ 达到目标覆盖率!")
                break

            # 2. 识别未测试路径
            untested = self.coverage_analyzer.identify_untested_paths(
                source_file,
                coverage
            )

            if not untested:
                print("  无法进一步提升覆盖率")
                break

            print(f"  发现 {len(untested)} 个未测试路径")

            # 3. 为未测试路径生成测试
            new_tests = self._generate_targeted_tests(
                source_file,
                untested[:3]  # 每次处理前3个
            )

            # 4. 追加到测试文件
            with open(test_file, "a") as f:
                f.write("\n\n" + new_tests)

            print(f"  ✓ 添加了新测试")

            iteration += 1

        return f"最终覆盖率: {current_coverage:.1%}"

    def _generate_targeted_tests(
        self,
        source_file: str,
        untested_paths: List[dict]
    ) -> str:
        """为特定路径生成测试"""
        with open(source_file, "r") as f:
            code = f.read()

        tests = []

        for path in untested_paths:
            prompt = f"""为以下未测试的代码路径生成测试:

函数: {path['function']}
行号: {path['line']}
类型: {path['type']}
代码: {path['code']}

完整函数实现:
```python
{code}
```

要求:
1. 专门针对这个路径编写测试
2. 确保能覆盖到这一行代码
3. 使用pytest格式

测试代码:"""

            messages = [HumanMessage(content=prompt)]
            response = self.generator.llm.invoke(messages)
            tests.append(response.content)

        return "\n\n".join(tests)
```

## 6.4 实战示例

```python
# 示例代码
example_code = """
def calculate_discount(price: float, customer_type: str) -> float:
    \"\"\"
    计算折扣后价格

    Args:
        price: 原价
        customer_type: 客户类型(vip/regular/new)

    Returns:
        折扣后价格

    Raises:
        ValueError: 价格为负或客户类型无效
    \"\"\"
    if price < 0:
        raise ValueError("价格不能为负")

    discount_rates = {
        "vip": 0.8,
        "regular": 0.9,
        "new": 0.95
    }

    if customer_type not in discount_rates:
        raise ValueError(f"无效的客户类型: {customer_type}")

    discount = discount_rates[customer_type]
    return price * discount
"""

# 生成测试
generator = TestGenerator(api_key="your-key")

print("生成测试用例...")
tests = generator.generate_tests(example_code, "calculate_discount")

print("\n生成的测试:")
print(tests)

# 保存测试文件
with open("test_discount.py", "w") as f:
    f.write("import pytest\n\n")
    f.write(example_code)
    f.write("\n\n")
    f.write(tests)

# 运行覆盖率分析
analyzer = CoverageAnalyzer()
coverage = analyzer.run_coverage("test_discount.py", "discount.py")

print(f"\n覆盖率: {coverage['line_coverage']:.1%}")
print(f"覆盖行数: {coverage['lines_covered']}/{coverage['lines_total']}")

if coverage['line_coverage'] < 90:
    print("\n覆盖率不足,生成补充测试...")
    incremental = IncrementalTestGenerator(api_key="your-key")
    result = incremental.improve_coverage("discount.py", "test_discount.py")
    print(result)
```

## 6.5 本章小结

### 核心要点

1. **AST驱动分析**: 提取函数特征,识别测试场景
2. **AI生成测试**: Claude 3.5 Sonnet理解代码意图
3. **覆盖率优化**: 迭代生成测试直到达标
4. **模板库加速**: 常见模式快速生成

### 测试生成效果

| 指标 | 数值 |
|------|------|
| 初始覆盖率 | 65-75% |
| 优化后覆盖率 | 85-95% |
| 生成速度 | 1-2分钟/函数 |
| 准确率 | 80-90% |

### 下一章预告

第7章将实现代码审查自动化:
- Git Diff智能解析
- 多维度质量评估
- 审查评论生成
- CI/CD集成

---

**下一章**: [第7章 代码审查自动化](./第7章_代码审查自动化.md) →
