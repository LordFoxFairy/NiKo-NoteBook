# 第34章 成本优化完全指南

> **难度**: ⭐⭐⭐⭐ | **推荐度**: ⭐⭐⭐⭐⭐

## 34.1 成本结构分析

### 34.1.1 硬件成本

```python
HARDWARE_OPTIONS = {
    "入门方案 (RTX 4060 Ti 16GB)": {
        "投资": 2000,  # $
        "能力": "SD 1.5/SDXL @ 512-768",
        "吞吐": "~100张/小时",
        "适合": "个人/小规模"
    },

    "标准方案 (RTX 4070 Ti 16GB)": {
        "投资": 3500,
        "能力": "SDXL @ 1024, Flux.1 @ 768",
        "吞吐": "~150张/小时",
        "适合": "中小企业"
    },

    "专业方案 (RTX 4090 24GB)": {
        "投资": 5000,
        "能力": "全模型流畅,视频生成可用",
        "吞吐": "~200张/小时",
        "适合": "专业工作室"
    },

    "企业方案 (4× RTX 4090)": {
        "投资": 20000,
        "能力": "批量生产",
        "吞吐": "~800张/小时",
        "适合": "规模化企业"
    }
}
```

### 34.1.2 API成本对比

```python
API_PRICING = {
    "DALL-E 3 (1024×1024 standard)": 0.040,
    "DALL-E 3 (1024×1024 hd)": 0.080,
    "Midjourney Basic (月)": 10,
    "Midjourney Standard (月)": 30,
    "Runway Gen-3 (5秒视频)": 0.45,
    "Pika 1.5 (5秒视频)": 0.20,
    "Kling AI (5秒高质量)": 0.37,
    "Suno AI Pro (月)": 10,
    "ElevenLabs Creator (月)": 22,
    "Replicate SDXL": 0.003,
    "Replicate Flux.1": 0.003
}

# 月生成1000张图成本对比
volumes = 1000

costs = {
    "本地RTX 4090": 130 + (volumes * 0.002),  # 固定成本+电费
    "DALL-E 3": volumes * 0.040,
    "Replicate SDXL": volumes * 0.003,
}

print("月生成1000张:")
for method, cost in costs.items():
    print(f"  {method}: ${cost:.2f}")

"""
输出:
月生成1000张:
  本地RTX 4090: $132.00
  DALL-E 3: $40.00
  Replicate SDXL: $3.00

结论: 1000张以下 → Replicate最划算
      5000张以上 → 本地最划算
"""
```

---

## 34.2 硬件优化策略

### 34.2.1 显存优化

```python
# 技巧1: 降低精度
model = StableDiffusionPipeline.from_pretrained(
    "model",
    torch_dtype=torch.float16  # fp16 vs fp32 → 减半VRAM
)

# 技巧2: xformers
pipe.enable_xformers_memory_efficient_attention()
# 节省20-30% VRAM

# 技巧3: CPU Offload
pipe.enable_model_cpu_offload()
# 大幅降低VRAM,但速度变慢

# 技巧4: Attention Slicing
pipe.enable_attention_slicing(slice_size=1)
# 用时间换空间

# 技巧5: VAE Slicing
pipe.enable_vae_slicing()
# 特别是大分辨率时有效

# 组合使用 (12GB卡跑SDXL)
pipe = StableDiffusionPipeline.from_pretrained(
    "sdxl",
    torch_dtype=torch.float16,
    variant="fp16"
).to("cuda")
pipe.enable_xformers_memory_efficient_attention()
pipe.enable_vae_slicing()
# 12GB可跑1024×1024
```

### 34.2.2 速度优化

```python
# 技巧1: Torch Compile (PyTorch 2.0+)
pipe.unet = torch.compile(pipe.unet, mode="reduce-overhead")
# 首次慢,后续快30%+

# 技巧2: 减少Steps (质量可接受时)
steps = 20  # vs 30-40
# 速度提升33-50%

# 技巧3: 使用快速采样器
scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
pipe.scheduler = scheduler
# DPM++比Euler快20%+

# 技巧4: TensorRT (高级,需单独安装)
# 速度可提升2-3倍,但配置复杂

# 技巧5: 批处理
images = pipe(
    prompt=[prompt1, prompt2, prompt3, prompt4],
    num_images_per_prompt=1
).images
# 批量比逐个快30%+
```

---

## 34.3 API成本优化

### 34.3.1 智能路由

```python
class CostOptimizedRouter:
    """智能成本路由器"""

    def __init__(self):
        self.local_pipe = load_local_sdxl()  # 本地模型
        self.replicate_client = ReplicateClient()
        self.dalle_client = OpenAI()

    def generate(self, prompt, quality="standard", budget="low"):
        """
        根据需求和预算自动选择最优方案
        """

        # 决策树
        if quality == "prototype":
            # 原型阶段: 本地最快
            return self.local_pipe(prompt).images[0]

        elif budget == "low" and quality == "standard":
            # 低预算+标准质量: Replicate
            return self.replicate_client.run(
                "stability-ai/sdxl",
                input={"prompt": prompt}
            )

        elif quality == "commercial":
            # 商业级: DALL-E 3
            return self.dalle_client.images.generate(
                prompt=prompt,
                model="dall-e-3",
                quality="hd"
            )

        else:
            # 默认: 本地
            return self.local_pipe(prompt).images[0]

# 使用
router = CostOptimizedRouter()

# 原型测试 (免费)
test_img = router.generate("test concept", quality="prototype")

# 批量生产 (低成本)
batch_imgs = [
    router.generate(p, quality="standard", budget="low")
    for p in prompts
]

# 关键交付 (高质量)
final_img = router.generate(key_prompt, quality="commercial")
```

### 34.3.2 缓存策略

```python
import hashlib
import pickle
from pathlib import Path

class CachedGenerator:
    """带缓存的生成器,避免重复生成"""

    def __init__(self, cache_dir="cache"):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(exist_ok=True)
        self.generator = create_generator()

    def _get_cache_key(self, prompt, params):
        """生成缓存key"""
        cache_string = f"{prompt}_{params}"
        return hashlib.md5(cache_string.encode()).hexdigest()

    def generate(self, prompt, **params):
        """先查缓存,未命中再生成"""
        cache_key = self._get_cache_key(prompt, str(params))
        cache_file = self.cache_dir / f"{cache_key}.pkl"

        if cache_file.exists():
            print(f"✓ 缓存命中: {prompt[:30]}...")
            with open(cache_file, "rb") as f:
                return pickle.load(f)

        # 缓存未命中,生成
        print(f"✗ 生成中: {prompt[:30]}...")
        image = self.generator(prompt, **params).images[0]

        # 保存缓存
        with open(cache_file, "wb") as f:
            pickle.dump(image, f)

        return image

# 使用
cached_gen = CachedGenerator()

# 第一次生成 (消耗成本)
img1 = cached_gen.generate("a fitness coach", steps=30)

# 第二次相同请求 (免费!)
img2 = cached_gen.generate("a fitness coach", steps=30)

# 节省: 重复请求成本为0
```

---

## 34.4 工作流优化

### 34.4.1 分层策略

```python
# 策略: 不同阶段用不同工具

WORKFLOW_STRATEGY = {
    "阶段1: 创意探索 (100+变体)": {
        "工具": "本地SD 1.5",
        "分辨率": "512×512",
        "Steps": 20,
        "成本": "~$0.5 (电费)",
        "时间": "2小时"
    },

    "阶段2: 精选迭代 (20个方向)": {
        "工具": "Replicate SDXL",
        "分辨率": "1024×1024",
        "Steps": 30,
        "成本": "20 × $0.003 = $0.06",
        "时间": "30分钟"
    },

    "阶段3: 最终交付 (5个成品)": {
        "工具": "DALL-E 3 HD 或 本地Flux.1",
        "分辨率": "1024×1024",
        "质量": "最高",
        "成本": "5 × $0.08 = $0.40",
        "时间": "15分钟"
    }
}

# 总成本: $0.96 vs 全程DALL-E 3 ($12.5)
# 节省: 92%
```

### 34.4.2 批量折扣

```python
# 批量操作降低单价

# 策略1: 利用Replicate批量定价
# 单个调用: $0.003/张
# 批量(100+): 可能有折扣,询问支持

# 策略2: 本地批处理
batch_size = 4  # 同时生成4张

images = pipe(
    prompt=[prompt] * batch_size,
    num_images_per_prompt=1
).images

# 4张耗时仅比1张多20%
# 实际单张时间: 原来的30%

# 策略3: API积分预充值
# 如Midjourney年付 ($288) vs 月付 ($360)
# 节省: 20%
```

---

## 34.5 实战案例: 月省$500方案

```python
# 原方案: 月生成3000张图 + 50个视频

ORIGINAL_COST = {
    "图片 (DALL-E 3)": 3000 * 0.04,  # $120
    "视频 (Runway)": 50 * 0.90,      # $45
    "音乐 (Suno Pro)": 10,            # $10
    "音效 (ElevenLabs)": 22,          # $22
    "总计": 197
}

# 优化方案

OPTIMIZED_COST = {
    "图片": {
        "工具": "本地RTX 4090",
        "成本": 130,  # 硬件摊销+电费
        "说明": "3000张本地生成"
    },

    "视频": {
        "工具": "Pika (30个) + Kling (20个)",
        "成本": 30 * 0.20 + 20 * 0.37,  # $13.4
        "说明": "常规用Pika,关键用Kling"
    },

    "音乐": {
        "工具": "Suno Pro",
        "成本": 10,
        "说明": "保持不变"
    },

    "音效": {
        "工具": "ElevenLabs Starter",
        "成本": 5,
        "说明": "降级到Starter计划"
    },

    "总计": 158.4
}

print("原方案月成本: $197")
print("优化后月成本: $158.4")
print("月节省: $38.6 (19.6%)")
print("\n年节省: $463 (足够买GPU升级!)")

# 硬件投资回收
hardware_investment = 1600  # RTX 4090
monthly_savings = 197 - 158.4
payback_months = hardware_investment / monthly_savings
print(f"\nGPU投资回本: {payback_months:.1f}个月")
```

---

## 34.6 成本监控

```python
# 建立成本监控系统

import sqlite3
from datetime import datetime

class CostTracker:
    """成本跟踪器"""

    def __init__(self, db_path="costs.db"):
        self.conn = sqlite3.connect(db_path)
        self.create_tables()

    def create_tables(self):
        self.conn.execute("""
            CREATE TABLE IF NOT EXISTS costs (
                id INTEGER PRIMARY KEY,
                timestamp TEXT,
                service TEXT,
                resource_type TEXT,
                quantity INTEGER,
                unit_cost REAL,
                total_cost REAL
            )
        """)

    def log_cost(self, service, resource_type, quantity, unit_cost):
        """记录成本"""
        total = quantity * unit_cost
        self.conn.execute("""
            INSERT INTO costs (timestamp, service, resource_type, quantity, unit_cost, total_cost)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (datetime.now().isoformat(), service, resource_type, quantity, unit_cost, total))
        self.conn.commit()

    def monthly_report(self):
        """月度报告"""
        cursor = self.conn.execute("""
            SELECT service, SUM(total_cost) as total
            FROM costs
            WHERE timestamp >= date('now', '-30 days')
            GROUP BY service
        """)

        print("\n月度成本报告:")
        print("-" * 40)
        total = 0
        for row in cursor:
            print(f"{row[0]:20s}: ${row[1]:.2f}")
            total += row[1]
        print("-" * 40)
        print(f"{'总计':20s}: ${total:.2f}")

# 使用
tracker = CostTracker()

# 记录每次生成
tracker.log_cost("Replicate", "image", 10, 0.003)
tracker.log_cost("Runway", "video", 1, 0.45)
tracker.log_cost("本地", "image", 100, 0.002)

# 月度报告
tracker.monthly_report()
```

---

## 34.7 总结

**成本优化核心策略**:

1. **分层生成**: 测试用低成本,交付用高质量
2. **智能路由**: 根据需求自动选择最优API
3. **本地优先**: 月生成>5000张必上GPU
4. **批量操作**: 利用批处理降低单价
5. **缓存复用**: 避免重复生成
6. **成本监控**: 实时跟踪,及时优化

**ROI计算公式**:
```python
def calculate_roi(monthly_volume, hardware_cost=1600):
    """计算GPU投资回报"""

    api_cost = monthly_volume * 0.04  # DALL-E 3
    local_cost = 130  # RTX 4090月成本

    if monthly_volume < 3250:
        return "API更划算"

    monthly_savings = api_cost - local_cost
    payback_months = hardware_cost / monthly_savings

    return f"投资GPU,{payback_months:.1f}月回本"

print(calculate_roi(5000))   # "投资GPU,9.8月回本"
print(calculate_roi(10000))  # "投资GPU,4.3月回本"
```

**关键指标**:
- 月生成<1000张 → Replicate API
- 月生成1000-5000张 → 混合方案
- 月生成>5000张 → 必投资GPU
- 年预算<$2000 → API订阅
- 年预算>$2000 → 自建硬件

成本优化不是降低质量,而是聪明地分配资源!
