# 第2章：模型家族谱系：从编码器到解码器 (Model Architectures)

> "The best way to predict the future is to invent it." - Alan Kay
>
> 本章将带你理解Transformer的三大架构分支，掌握每种架构的设计哲学、技术细节和2025年的主流选择，助你在实际应用中做出明智的架构选型。

---

## 目录
- [一、共同的祖先：编码器-解码器架构](#一共同的祖先编码器-解码器架构)
  - [1.1 原始Transformer的双塔设计](#11-原始transformer的双塔设计)
  - [1.2 编码器-解码器的工作流程](#12-编码器-解码器的工作流程)
  - [1.3 T5：现代编码器-解码器的代表](#13-t5现代编码器-解码器的代表)
- [二、分裂与演化：为何不都用编码器-解码器？](#二分裂与演化为何不都用编码器-解码器)
  - [2.1 计算效率考量](#21-计算效率考量)
  - [2.2 任务特性适配](#22-任务特性适配)
- [三、仅编码器架构：双向的理解专家](#三仅编码器架构双向的理解专家)
  - [3.1 BERT的革命性设计](#31-bert的革命性设计)
  - [3.2 掩码语言模型 (MLM)](#32-掩码语言模型-mlm)
  - [3.3 为什么BERT不能生成文本？](#33-为什么bert不能生成文本)
  - [3.4 实战：BERT文本分类](#34-实战bert文本分类)
- [四、仅解码器架构：生成的王者](#四仅解码器架构生成的王者)
  - [4.1 GPT的单向设计哲学](#41-gpt的单向设计哲学)
  - [4.2 因果注意力机制 (Causal Mask)](#42-因果注意力机制-causal-mask)
  - [4.3 2025年视角：Decoder-only的全面胜利](#43-2025年视角decoder-only的全面胜利)
  - [4.4 实战：GPT文本生成](#44-实战gpt文本生成)
- [五、架构选型指南](#五架构选型指南)
  - [5.1 三大架构对比表](#51-三大架构对比表)
  - [5.2 决策树：我该用哪个？](#52-决策树我该用哪个)
  - [5.3 黄金组合：Encoder做索引，Decoder做生成](#53-黄金组合encoder做索引decoder做生成)
- [六、深度问答](#六深度问答)

---

**本章概览**

在第1章中，我们深入学习了Transformer的核心机制。但你是否好奇：**为什么BERT擅长理解文本，而GPT擅长生成文本？为什么现在的新模型（如DeepSeek-V3, LLaMA-3）几乎全都是Decoder-only架构？**

这一切的答案，藏在Transformer的**三大架构分支**中：

```mermaid
graph TD
    A[Transformer 原始架构<br>Encoder-Decoder 2017] --> B[仅编码器<br>Encoder-only]
    A --> C[仅解码器<br>Decoder-only]
    A --> D[编码器-解码器<br>Encoder-Decoder]

    B --> B1[BERT 2018<br>RoBERTa 2019<br>Embedding Models 2025]
    C --> C1[GPT-3/4 2020-2023<br>LLaMA-3 2024<br>DeepSeek-V3 2024]
    D --> D1[T5 2020<br>BART 2020<br>GLM-130B 2022]

    style A fill:#FFE4E1,stroke:#E87461
    style B fill:#E8F5E9,stroke:#81C784
    style C fill:#E3F2FD,stroke:#64B5F6,stroke-width:3px
    style D fill:#FFF9C4,stroke:#FDD835
    style C1 fill:#BBDEFB,stroke:#1976D2,stroke-width:2px
```

**难度级别**：⭐⭐（进阶）- 需要理解第1章的Transformer基础

---

## 一、共同的祖先：编码器-解码器架构

### 1.1 原始Transformer的双塔设计

2017年，论文《Attention is All You Need》提出的Transformer，采用的是**编码器-解码器（Encoder-Decoder）**结构，最初是为了解决机器翻译任务：

```mermaid
graph LR
    subgraph Encoder[编码器：理解源语言]
    A[输入: I love AI] --> B[双向Attention]
    B --> C[语义向量]
    end

    subgraph Decoder[解码器：生成目标语言]
    D[输入: <start>] --> E[Masked Attention]
    E --> F[Cross Attention]
    C -.-> F
    F --> G[输出: 我]
    G -.-> D
    end

    style Encoder fill:#E8F5E9
    style Decoder fill:#E3F2FD
```

**核心设计理念**：
- **编码器（Encoder）**：使用**双向注意力**，同时看到整个输入句子，提取深层语义。
- **解码器（Decoder）**：使用**因果注意力**（只看左边），自回归地生成目标句子。
- **交叉注意力（Cross-Attention）**：连接两座塔的桥梁，让解码器在生成每个字时都能"回头看"编码器的信息。

### 1.2 编码器-解码器的工作流程

以翻译 "I love AI" -> "我爱AI" 为例：

1. **编码阶段**：Encoder 读入完整句子 "I love AI"，将其转化为一系列高维向量（Memory）。
2. **解码阶段 - Step 1**：Decoder 接收 `<start>`，此时通过 **Cross-Attention** 查询 Memory，重点关注 "I"，输出 "我"。
3. **解码阶段 - Step 2**：Decoder 接收 `<start> 我`，关注 "love"，输出 "爱"。
4. **解码阶段 - Step 3**：Decoder 接收 `<start> 我 爱`，关注 "AI"，输出 "AI"。

### 1.3 T5：现代编码器-解码器的代表

Google 在 2020 年提出的 **T5 (Text-to-Text Transfer Transformer)** 将这种架构推向了极致。它提出一个核心观点：**所有NLP任务都可以视为文本到文本的转换**。

- **翻译**：`translate English to German: That is good.` -> `Das ist gut.`
- **分类**：`cola sentence: The course is jumping well.` -> `not acceptable`
- **摘要**：`summarize: state authorities dispatched emergency crews...` -> `six people hospitalized...`

T5 证明了 Encoder-Decoder 架构在多任务统一上的强大能力，特别是对于输入输出都需要理解的任务（如翻译、摘要）。

---

## 二、分裂与演化：为何不都用编码器-解码器？

既然 Encoder-Decoder 全能，为什么后来分化出了 BERT 和 GPT？

### 2.1 计算效率考量
Encoder-Decoder 需要维护两套参数（编码器和解码器），且推理时需要两个模块协同工作。
- 对于**分类任务**（如情感分析），只需要输出一个标签，用 Decoder 是杀鸡用牛刀。
- 对于**生成任务**（如写小说），输入就是上文，不需要单独的 Encoder 去编码一个"源文本"，直接用 Decoder 自回归即可。

### 2.2 任务特性适配
- **理解密集型**：情感分析、实体识别、文本匹配。需要**双向**上下文（既看左也看右）。👉 **Encoder-only (BERT)**
- **生成密集型**：创意写作、代码补全、对话。需要**自回归**生成（只能看左，不能剧透）。👉 **Decoder-only (GPT)**

---

## 三、仅编码器架构：双向的理解专家

### 3.1 BERT的革命性设计

**BERT (Bidirectional Encoder Representations from Transformers)** 砍掉了 Transformer 的解码器，只保留编码器。

**核心武器：双向注意力 (Bidirectional Attention)**
GPT 只能从左到右看（为了生成），这导致它在理解语境时有缺陷。例如：
> "I went to the **bank** to deposit money."
> "I went to the **bank** of the river."

BERT 能同时看到 "bank" 左右的词（"deposit money" 或 "river"），从而精准判断 "bank" 是"银行"还是"河岸"。

### 3.2 掩码语言模型 (MLM)

为了训练双向模型，BERT 发明了 **MLM (Masked Language Modeling)** 任务，类似"完形填空"：

> 原句：The cat sat on the mat.
>
> 输入：The cat [MASK] on the mat.
>
> 目标：预测 [MASK] 是 "sat"。

**代码实战：BERT 做完形填空**

```python
from transformers import pipeline

fill_mask = pipeline("fill-mask", model="bert-base-uncased")
result = fill_mask("Paris is the [MASK] of France.")

print(result)
# 输出: [{'score': 0.99, 'token_str': 'capital', ...}]
```

### 3.3 为什么BERT不能生成文本？

这是一个常见的面试题：**BERT 既然理解能力这么强，为什么不能用来写文章？**

1. **预训练目标不同**：BERT 训练的是"填空"能力，不是"预测下一个词"的能力。它习惯了看到完整的上下文。
2. **双向注意力的泄露**：在生成时，如果使用双向注意力，生成第 $t$ 个词时会看到第 $t+1$ 个词的信息（这在训练时是存在的，但在真实生成时通过 Mask 可以在技术上屏蔽，但模型并未适应这种单向语境）。
3. **独立性假设**：BERT 预测 [MASK] 时假设各个 [MASK] 是独立的（在非自回归变体中），而文本生成强依赖词与词的顺序关联。

### 3.4 实战：BERT文本分类

BERT 最擅长的是将变长的文本压缩成一个定长的向量（通常取 `[CLS]` token 的向量），用于分类。

```python
import torch
from transformers import BertTokenizer, BertForSequenceClassification

# 1. 加载模型
model_name = "bert-base-uncased"
tokenizer = BertTokenizer.from_pretrained(model_name)
model = BertForSequenceClassification.from_pretrained(model_name, num_labels=2)

# 2. 准备输入
text = "This movie is absolutely fantastic!"
inputs = tokenizer(text, return_tensors="pt")

# 3. 前向传播
with torch.no_grad():
    outputs = model(**inputs)
    logits = outputs.logits
    prediction = torch.argmax(logits, dim=-1)

print(f"预测类别: {prediction.item()}")
```

---

## 四、仅解码器架构：生成的王者

### 4.1 GPT的单向设计哲学

**GPT (Generative Pre-trained Transformer)** 砍掉了 Transformer 的编码器，只保留解码器。

它的哲学非常简单粗暴：**预测下一个词 (Next Token Prediction)**。
不需要复杂的 Mask 策略，不需要区分源文本和目标文本，就是把整个互联网的文本读一遍，尝试预测每一个词的下一个词是什么。

$$ P(\text{text}) = \prod_{i=1}^{n} P(w_i | w_1, ..., w_{i-1}) $$

### 4.2 因果注意力机制 (Causal Mask)

GPT 的核心在于**Causal Mask（因果掩码）**，保证预测 $w_i$ 时只能看到 $w_1$ 到 $w_{i-1}$，绝不能看到后面。

**Causal Mask 的形状与实现**：
它是一个下三角矩阵（上三角部分被处理为负无穷大，Softmax 后变为 0）。

```python
import torch
import matplotlib.pyplot as plt

def create_causal_mask(size):
    # 创建一个全1矩阵
    mask = torch.ones(size, size)
    # 提取下三角，上三角置0
    mask = torch.tril(mask)
    return mask

# 示例：长度为5的序列
# 行i表示第i个token，列j表示它关注的token
mask = create_causal_mask(5)
print(mask)
"""
输出:
tensor([[1., 0., 0., 0., 0.],  # 第1个词只能看自己
        [1., 1., 0., 0., 0.],  # 第2个词看前2个
        [1., 1., 1., 0., 0.],
        [1., 1., 1., 1., 0.],
        [1., 1., 1., 1., 1.]]) # 第5个词看全部
"""
```

### 4.3 2025年视角：Decoder-only的全面胜利

在 2018-2020 年，BERT 和 GPT 各领风骚。但在 2025 年的今天，**Decoder-only 架构已经统治了通用大模型领域**。

**主流模型清单 (2025)**：
- **OpenAI GPT-4/o1**：Decoder-only
- **Meta LLaMA 3**：Decoder-only
- **DeepSeek-V3/R1**：Decoder-only (配合 MoE)
- **Anthropic Claude 3.5**：Decoder-only

**胜出原因**：

1. **Scaling Law (扩展定律)**：研究发现，在极大规模参数下，Causal Decoder 的训练效率最高，最容易扩展。BERT 的 MLM 任务每个样本只能学习 15% 的 token（被 mask 的那些），而 GPT 的 Next Token Prediction 每个样本的所有 token 都能产生 loss，**数据利用率更高**。
2. **In-Context Learning (上下文学习)**：这是 GPT-3 发现的涌现能力。Decoder-only 架构天然符合人类"说话"的顺序，给它几个示例（Few-shot），它就能依葫芦画瓢地生成后续内容。这种通用性通过 Prompt 实现了无需微调即可处理多种任务。
3. **推理优化的成熟**：KV Cache 等技术让 Decoder-only 的生成速度大幅提升，工业界围绕这一架构建立的生态（vLLM, TensorRT-LLM）最为完善。

> **注意**：DeepSeek-V3 虽然引入了 MLA (Multi-head Latent Attention) 等改进，DeepSeek-R1 引入了强化学习训练推理能力，但它们的骨架依然是 **Decoder-only Transformer**。这一点至关重要。

### 4.4 实战：GPT文本生成

使用 `AutoModelForCausalLM` 进行生成。

```python
from transformers import GPT2LMHeadModel, GPT2Tokenizer

model_name = "gpt2"
tokenizer = GPT2Tokenizer.from_pretrained(model_name)
model = GPT2LMHeadModel.from_pretrained(model_name)

prompt = "The future of AI is"
inputs = tokenizer(prompt, return_tensors="pt")

# 生成配置
output = model.generate(
    **inputs,
    max_length=50,
    temperature=0.7,    # 控制随机性：越低越保守，越高越奔放
    top_p=0.9,          # 核采样：保留累积概率90%的词
    do_sample=True      # 启用采样，否则是贪婪搜索
)

print(tokenizer.decode(output[0], skip_special_tokens=True))
# 可能的输出: "The future of AI is bright. With transformers leading the way..."
```

---

## 五、架构选型指南

在 2025 年实际构建应用时，我们该如何选择？

### 5.1 三大架构对比表

| 特性 | Encoder-only (BERT类) | Decoder-only (GPT类) | Encoder-Decoder (T5类) |
| :--- | :--- | :--- | :--- |
| **可见范围** | 双向 (Bi-directional) | 单向 (Uni-directional) | 混合 (Mixed) |
| **擅长任务** | 文本分类、命名实体识别、**语义嵌入** | **文本生成**、对话、逻辑推理 | 翻译、摘要 (逐渐被Decoder替代) |
| **代表模型** | BERT, RoBERTa, **BGE-M3** | GPT-4, LLaMA 3, **DeepSeek-V3** | T5, UL2 |
| **缺点** | 很难生成长文本 | 只能看左边，嵌入质量略逊 | 结构复杂，推理慢 |

### 5.2 决策树：我该用哪个？

1. **如果你要把文本变成向量 (Embedding)** -> **Encoder-only**
   - 场景：RAG 中的知识库索引、语义搜索、聚类。
   - 选型：`bge-m3`, `nomic-embed-text`, `text-embedding-3-small` (OpenAI 虽然是闭源，但内部通常也是基于双向注意力优化的)。

2. **如果你要生成文本、回答问题、写代码** -> **Decoder-only**
   - 场景：聊天机器人、写作助手、Agent。
   - 选型：`DeepSeek-V3`, `Claude 3.5`, `Llama 3`, `GPT-4`。

3. **如果你要处理极其不对称的转换** -> **Encoder-Decoder** (较少见)
   - 场景：语音转文字 (Whisper)、复杂的机器翻译（尽管 GPT 也能做，但专用模型有时更精准）。

### 5.3 黄金组合：Encoder做索引，Decoder做生成

在最流行的 **RAG (Retrieval-Augmented Generation)** 架构中，我们通常结合使用两者：

1. 用 **Encoder** 模型（如 BERT 变体）将百万文档转化为向量库。
2. 用户提问时，先检索出相关文档。
3. 用 **Decoder** 模型（如 GPT-4）阅读检索到的文档并回答用户问题。

这是目前企业级应用的标准范式。

---

## 六、深度问答

**Q1: 既然 Decoder-only 是主流，BERT 是不是被淘汰了？**
A: **没有**。在 Embedding 领域（将文本转化为向量），Encoder-only 架构依然是绝对王者。因为理解一句话的语义，必须同时看到前后文。目前最强的开源 Embedding 模型（如 BGE, E5 等）本质上都是 BERT 的现代变体。

**Q2: T5 这种 Encoder-Decoder 还有人用吗？**
A: 在多模态领域（如音频转文本 Whisper、图像生成 Imagen）依然广泛使用。但在纯文本生成领域，确实正在被 Decoder-only 取代，因为后者在 Scaling 上更具优势。

**Q3: DeepSeek-R1 / o1 是什么架构？**
A: 它们的基础架构依然是 **Decoder-only Transformer**。它们的"推理能力"主要来自**后训练阶段 (Post-training)** 的强化学习（RL）策略，而不是改变了 Transformer 的底层积木。这些内容将在 [Part 7 第4章] 详细拆解。

**Q4: 我只做很简单的文本分类，该用什么？**
A: 如果数据量少且算力受限，微调一个 `DistilBERT` (6层 BERT) 依然是最佳选择，速度快、效果好、成本低。如果不想微调，直接用 LLM (GPT) 做 Few-shot 也可以，但成本较高。

---

> **下一章预告**：知道了架构，这些模型是如何"炼"出来的？MLM 和 Next Token Prediction 到底是如何让模型产生智能的？下一章《预训练的奥秘》将揭晓。
